<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hand Tracking - MediaPipe</title>
    <!-- MediaPipe dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <link data-trunk rel="rust" href="Cargo.toml" data-wasm-opt="z" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Rajdhani:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* CSS Variables matching too.foo design system */
        :root {
            --bg: #050508;
            --bg-alt: #08080c;
            --surface: rgba(10, 15, 20, 0.85);
            --surface-hover: rgba(0, 20, 30, 0.9);
            --text: #e0e0e0;
            --text-muted: rgba(255, 255, 255, 0.8);
            --text-dim: rgba(255, 255, 255, 0.6);
            --text-faint: rgba(255, 255, 255, 0.4);
            --accent: #00ffff;
            --accent-bright: #00ff00;
            --accent-dim: rgba(0, 255, 255, 0.2);
            --accent-faint: rgba(0, 255, 255, 0.1);
            --border: rgba(0, 255, 255, 0.2);
            --border-dim: rgba(0, 255, 255, 0.15);
            --border-hover: rgba(0, 255, 255, 0.6);
            --shadow: rgba(0, 0, 0, 0.5);
            --glow: rgba(0, 255, 255, 0.3);
            --glow-strong: rgba(0, 255, 255, 0.6);
            --danger: #ff4444;
            --success: #00ff88;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Rajdhani', sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        #container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        #canvas-wrapper {
            flex: 1;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }

        canvas {
            display: block;
            max-width: 100%;
            max-height: 100%;
            background: #000;
        }

        #sidebar {
            width: 320px;
            background: var(--bg-alt);
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid var(--border-dim);
        }

        h1 {
            font-family: 'Rajdhani', sans-serif;
            font-size: 24px;
            font-weight: 700;
            margin-bottom: 8px;
            color: var(--accent);
        }

        h2 {
            font-family: 'Rajdhani', sans-serif;
            font-size: 16px;
            font-weight: 600;
            margin: 16px 0 8px;
            color: var(--accent-bright);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .subtitle {
            color: var(--text-dim);
            font-size: 12px;
            margin-bottom: 16px;
        }

        .mode-selector {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            margin-bottom: 16px;
        }

        .mode-btn {
            padding: 10px 8px;
            background: var(--surface);
            color: var(--text-dim);
            border: 1px solid var(--border-dim);
            border-radius: 4px;
            font-family: 'Rajdhani', sans-serif;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .mode-btn:hover {
            background: var(--surface-hover);
            border-color: var(--border);
        }

        .mode-btn.active {
            background: var(--accent-faint);
            border-color: var(--accent);
            color: var(--accent);
            box-shadow: 0 0 15px var(--glow);
        }

        .mode-btn .icon {
            font-size: 20px;
            display: block;
            margin-bottom: 4px;
        }

        .metric {
            margin: 6px 0;
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            background: var(--surface);
            border: 1px solid var(--border-dim);
            font-size: 13px;
        }

        .metric-label {
            color: var(--text-dim);
        }

        .metric-value {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 500;
            color: var(--accent);
        }

        .metric-value.detected {
            color: var(--success);
        }

        .metric-value.not-detected {
            color: var(--danger);
        }

        button {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            background: var(--accent-faint);
            color: var(--accent);
            border: 1px solid var(--accent);
            font-family: 'Rajdhani', sans-serif;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            background: var(--accent-dim);
            box-shadow: 0 0 20px var(--glow);
        }

        button:disabled {
            background: var(--surface);
            color: var(--text-faint);
            border-color: var(--border-dim);
            cursor: not-allowed;
            box-shadow: none;
        }

        .slider-control {
            margin: 10px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            font-size: 11px;
            color: var(--text-dim);
        }

        .slider-value {
            color: var(--accent);
            font-family: 'JetBrains Mono', monospace;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--surface);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            border: 1px solid var(--border-dim);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px var(--glow);
        }

        .info {
            font-size: 11px;
            color: var(--text-dim);
            margin-top: 16px;
            line-height: 1.6;
            padding: 12px;
            background: var(--accent-faint);
            border-left: 3px solid var(--accent);
        }

        .info strong {
            color: var(--accent);
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .status-indicator.active {
            background: var(--success);
            box-shadow: 0 0 8px var(--success);
        }

        .status-indicator.inactive {
            background: var(--danger);
        }

        .mode-info {
            display: none;
        }

        .mode-info.active {
            display: block;
        }

        /* RPS specific */
        .rps-result {
            text-align: center;
            padding: 12px;
            background: var(--surface);
            border: 1px solid var(--border-dim);
            margin: 8px 0;
        }

        .rps-result .big {
            font-size: 32px;
            margin: 8px 0;
        }

        .rps-score {
            display: flex;
            justify-content: space-around;
            margin-top: 8px;
        }

        .score-item {
            text-align: center;
        }

        .score-item .num {
            font-family: 'JetBrains Mono', monospace;
            font-size: 24px;
            font-weight: bold;
        }

        /* Drawing specific */
        .color-picker {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin: 8px 0;
        }

        .color-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: 2px solid var(--border-dim);
            cursor: pointer;
            transition: all 0.2s;
        }

        .color-btn:hover {
            border-color: var(--border);
        }

        .color-btn.active {
            border-color: #fff;
            transform: scale(1.1);
            box-shadow: 0 0 10px var(--glow);
        }

        /* Input styling */
        input[type="text"] {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            font-family: 'Rajdhani', sans-serif;
        }

        input[type="text"]:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 10px var(--glow);
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           MOBILE TOOLBAR & SLIDE-UP MENU
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

        /* Mobile bottom toolbar - hidden on desktop */
        #mobile-toolbar {
            display: none;
        }

        /* Mobile slide-up menu - hidden on desktop */
        #mobile-menu {
            display: none;
        }

        /* Mobile menu overlay */
        #mobile-overlay {
            display: none;
        }

        @media (max-width: 768px) {
            body {
                overflow: hidden;
            }

            /* Full screen canvas on mobile */
            #container {
                height: 100vh;
                height: 100dvh; /* Dynamic viewport height for mobile browsers */
            }

            #canvas-wrapper {
                flex: 1;
                width: 100%;
                height: calc(100vh - 60px);
                height: calc(100dvh - 60px);
            }

            canvas {
                width: 100% !important;
                height: 100% !important;
                object-fit: cover;
            }

            /* Hide desktop sidebar on mobile */
            #sidebar {
                display: none;
            }

            /* Mobile bottom toolbar */
            #mobile-toolbar {
                display: flex;
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                height: 60px;
                background: rgba(5, 5, 8, 0.95);
                backdrop-filter: blur(10px);
                border-top: 1px solid var(--border);
                align-items: center;
                justify-content: space-between;
                padding: 0 12px;
                z-index: 100;
                gap: 8px;
            }

            .toolbar-mode {
                display: flex;
                align-items: center;
                gap: 8px;
                flex: 1;
                min-width: 0;
            }

            .toolbar-mode-icon {
                font-size: 24px;
            }

            .toolbar-mode-name {
                font-size: 14px;
                font-weight: 600;
                color: var(--accent);
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .toolbar-btn {
                width: 44px;
                height: 44px;
                min-width: 44px;
                border-radius: 50%;
                background: var(--surface);
                border: 1px solid var(--border);
                color: var(--text);
                font-size: 20px;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                transition: all 0.2s;
                padding: 0;
                margin: 0;
            }

            .toolbar-btn:hover, .toolbar-btn:active {
                background: var(--accent-dim);
                border-color: var(--accent);
            }

            .toolbar-btn.active {
                background: var(--accent);
                color: var(--bg);
                border-color: var(--accent);
            }

            .toolbar-btn.camera-on {
                background: var(--success);
                border-color: var(--success);
                color: var(--bg);
            }

            /* Mobile overlay */
            #mobile-overlay {
                display: none;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.6);
                z-index: 150;
                opacity: 0;
                transition: opacity 0.3s;
            }

            #mobile-overlay.visible {
                display: block;
                opacity: 1;
            }

            /* Mobile slide-up menu */
            #mobile-menu {
                display: block;
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                max-height: 75vh;
                background: var(--bg-alt);
                border-top: 1px solid var(--accent);
                border-radius: 20px 20px 0 0;
                z-index: 200;
                transform: translateY(100%);
                transition: transform 0.3s ease-out;
                overflow: hidden;
            }

            #mobile-menu.open {
                transform: translateY(0);
            }

            .menu-handle {
                width: 40px;
                height: 4px;
                background: var(--border);
                border-radius: 2px;
                margin: 12px auto;
            }

            .menu-content {
                padding: 0 16px 24px;
                overflow-y: auto;
                max-height: calc(75vh - 28px);
            }

            /* Mode grid - all 6 visible */
            .mobile-mode-grid {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 10px;
                margin-bottom: 20px;
            }

            .mobile-mode-btn {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 12px 8px;
                background: var(--surface);
                border: 1px solid var(--border-dim);
                border-radius: 12px;
                color: var(--text-dim);
                font-family: 'Rajdhani', sans-serif;
                font-size: 11px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.2s;
                min-height: 70px;
            }

            .mobile-mode-btn:active {
                transform: scale(0.95);
            }

            .mobile-mode-btn.active {
                background: var(--accent-faint);
                border-color: var(--accent);
                color: var(--accent);
                box-shadow: 0 0 15px var(--glow);
            }

            .mobile-mode-btn .icon {
                font-size: 24px;
                margin-bottom: 4px;
            }

            /* Menu sections */
            .menu-section {
                margin-bottom: 16px;
            }

            .menu-section-title {
                font-size: 12px;
                font-weight: 600;
                color: var(--accent-bright);
                text-transform: uppercase;
                letter-spacing: 1px;
                margin-bottom: 8px;
            }

            /* Camera button in menu */
            .menu-camera-btn {
                width: 100%;
                padding: 14px;
                background: var(--accent-faint);
                border: 1px solid var(--accent);
                border-radius: 8px;
                color: var(--accent);
                font-family: 'Rajdhani', sans-serif;
                font-size: 14px;
                font-weight: 600;
                cursor: pointer;
                margin-bottom: 12px;
            }

            .menu-camera-btn.active {
                background: var(--success);
                border-color: var(--success);
                color: var(--bg);
            }

            /* Mode-specific controls in menu */
            .menu-mode-controls {
                background: var(--surface);
                border: 1px solid var(--border-dim);
                border-radius: 8px;
                padding: 12px;
            }

            .menu-mode-controls h3 {
                font-size: 13px;
                color: var(--accent);
                margin-bottom: 8px;
            }

            /* Touch-friendly controls */
            .menu-mode-controls button {
                padding: 12px;
                font-size: 13px;
                margin: 6px 0;
                min-height: 44px;
                border-radius: 8px;
            }

            .menu-mode-controls .color-btn {
                width: 40px;
                height: 40px;
                min-width: 40px;
            }

            .menu-mode-controls input[type="range"] {
                height: 8px;
            }

            .menu-mode-controls input[type="range"]::-webkit-slider-thumb {
                width: 24px;
                height: 24px;
            }

            /* Compact metrics in menu */
            .menu-metrics {
                display: flex;
                gap: 8px;
                flex-wrap: wrap;
            }

            .menu-metric {
                flex: 1;
                min-width: 80px;
                padding: 8px 10px;
                background: var(--surface);
                border: 1px solid var(--border-dim);
                border-radius: 6px;
                font-size: 11px;
            }

            .menu-metric-label {
                color: var(--text-dim);
                display: block;
            }

            .menu-metric-value {
                font-family: 'JetBrains Mono', monospace;
                color: var(--accent);
                font-weight: 600;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-wrapper">
            <canvas id="canvas"></canvas>
            <div id="no-camera" style="display: flex; flex-direction: column; align-items: center; justify-content: center; position: absolute; top: 0; left: 0; right: 0; bottom: 0; color: var(--text-dim); text-align: center; padding: 20px;">
                <p style="font-size: 64px; margin-bottom: 16px;">âœ‹</p>
                <p style="font-size: 18px; font-weight: 600; color: var(--accent);">Tap ğŸ“· to Start Camera</p>
            </div>
        </div>
        <div id="sidebar">
            <h1>âœ‹ Hand Tracking</h1>
            <p class="subtitle">Interactive demos powered by MediaPipe ML</p>

            <h2>Mode</h2>
            <div class="mode-selector">
                <button class="mode-btn active" data-mode="tracking">
                    <span class="icon">ğŸ‘†</span>
                    Tracking
                </button>
                <button class="mode-btn" data-mode="particles">
                    <span class="icon">âœ¨</span>
                    Particles
                </button>
                <button class="mode-btn" data-mode="theremin">
                    <span class="icon">ğŸµ</span>
                    Theremin
                </button>
                <button class="mode-btn" data-mode="rps">
                    <span class="icon">âœŠ</span>
                    RPS Game
                </button>
                <button class="mode-btn" data-mode="drawing">
                    <span class="icon">ğŸ¨</span>
                    Air Draw
                </button>
                <button class="mode-btn" data-mode="notes">
                    <span class="icon">ğŸ“</span>
                    Notes
                </button>
            </div>

            <h2>Camera</h2>
            <button id="camera-btn">Start Camera</button>
            <div class="metric">
                <span class="metric-label">
                    <span class="status-indicator inactive" id="camera-status"></span>
                    Status
                </span>
                <span class="metric-value" id="camera-status-text">Off</span>
            </div>

            <!-- Tracking Mode Info -->
            <div class="mode-info active" id="info-tracking">
                <h2>Detection</h2>
                <div class="metric">
                    <span class="metric-label">Hands</span>
                    <span class="metric-value" id="hands-count">0</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Gesture</span>
                    <span class="metric-value" id="gesture">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">FPS</span>
                    <span class="metric-value" id="fps">--</span>
                </div>
                <div class="info">
                    <strong>Hand Tracking</strong><br>
                    Show your hands to see 21 landmarks tracked in real-time. Try different gestures!
                </div>
            </div>

            <!-- Particles Mode Info -->
            <div class="mode-info" id="info-particles">
                <h2>Particle Settings</h2>
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Particle Count</span>
                        <span class="slider-value" id="particle-count-value">50</span>
                    </div>
                    <input type="range" id="particle-count" min="10" max="200" value="50">
                </div>
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Trail Length</span>
                        <span class="slider-value" id="trail-length-value">20</span>
                    </div>
                    <input type="range" id="trail-length" min="5" max="50" value="20">
                </div>
                <div class="info">
                    <strong>Particle Magic</strong><br>
                    Particles follow your fingertips! Make a fist to create an explosion effect.
                </div>
            </div>

            <!-- Theremin Mode Info -->
            <div class="mode-info" id="info-theremin">
                <h2>Theremin</h2>
                <button id="unlock-audio-btn" style="background: var(--accent); color: var(--bg); display: none;">ğŸ”Š Tap to Enable Sound</button>
                <div class="metric">
                    <span class="metric-label">Frequency</span>
                    <span class="metric-value" id="theremin-freq">--</span>
                </div>
                <div class="metric">
                    <span class="metric-label">Volume</span>
                    <span class="metric-value" id="theremin-vol">--</span>
                </div>
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Min Frequency</span>
                        <span class="slider-value" id="min-freq-value">100</span>
                    </div>
                    <input type="range" id="min-freq" min="50" max="300" value="100">
                </div>
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Max Frequency</span>
                        <span class="slider-value" id="max-freq-value">800</span>
                    </div>
                    <input type="range" id="max-freq" min="400" max="2000" value="800">
                </div>
                <div class="info">
                    <strong>Virtual Theremin</strong><br>
                    âœ‹ <strong>Right hand</strong> - Open/close for pitch<br>
                    ğŸ¤š <strong>Left hand</strong> - Open/close for volume<br>
                    Fist = low/mute, Open = high/loud
                </div>
            </div>

            <!-- RPS Mode Info -->
            <div class="mode-info" id="info-rps">
                <h2>Rock Paper Scissors</h2>
                <div class="rps-result">
                    <div>Your move:</div>
                    <div class="big" id="rps-your-move">?</div>
                    <div>vs Computer:</div>
                    <div class="big" id="rps-computer-move">?</div>
                    <div id="rps-result-text" style="margin-top: 8px; font-weight: bold;">Show your hand!</div>
                </div>
                <div class="rps-score">
                    <div class="score-item">
                        <div class="num" id="rps-wins" style="color: var(--success);">0</div>
                        <div style="color: var(--text-dim); font-size: 11px;">Wins</div>
                    </div>
                    <div class="score-item">
                        <div class="num" id="rps-ties" style="color: var(--accent);">0</div>
                        <div style="color: var(--text-dim); font-size: 11px;">Ties</div>
                    </div>
                    <div class="score-item">
                        <div class="num" id="rps-losses" style="color: var(--danger);">0</div>
                        <div style="color: var(--text-dim); font-size: 11px;">Losses</div>
                    </div>
                </div>
                <button id="rps-play-btn" style="margin-top: 12px;">Play Round</button>
                <div class="info">
                    <strong>Rock Paper Scissors</strong><br>
                    âœŠ Fist = Rock<br>
                    âœ‹ Open Palm = Paper<br>
                    âœŒï¸ Peace = Scissors
                </div>
            </div>

            <!-- Drawing Mode Info -->
            <div class="mode-info" id="info-drawing">
                <h2>Drawing</h2>
                <div class="color-picker">
                    <div class="color-btn active" data-color="#00ffff" style="background: #00ffff;"></div>
                    <div class="color-btn" data-color="#00ff88" style="background: #00ff88;"></div>
                    <div class="color-btn" data-color="#ffff00" style="background: #ffff00;"></div>
                    <div class="color-btn" data-color="#ff6600" style="background: #ff6600;"></div>
                    <div class="color-btn" data-color="#ff44ff" style="background: #ff44ff;"></div>
                    <div class="color-btn" data-color="#ffffff" style="background: #ffffff;"></div>
                </div>
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Brush Size</span>
                        <span class="slider-value" id="brush-size-value">8</span>
                    </div>
                    <input type="range" id="brush-size" min="2" max="30" value="8">
                </div>
                <button id="clear-drawing-btn">Clear Canvas</button>
                <div class="info">
                    <strong>Air Drawing</strong><br>
                    Point with your index finger to draw. Make a fist to stop drawing. Pinch (thumb + index) to erase!
                </div>
            </div>

            <!-- Notes Mode Info -->
            <div class="mode-info" id="info-notes">
                <h2>Visual Notes</h2>
                <div class="metric">
                    <span class="metric-label">Status</span>
                    <span class="metric-value" id="notes-mode">Ready</span>
                </div>
                <div class="color-picker" id="notes-colors">
                    <div class="color-btn active" data-color="#00ffff" style="background: #00ffff;"></div>
                    <div class="color-btn" data-color="#00ff88" style="background: #00ff88;"></div>
                    <div class="color-btn" data-color="#ffff00" style="background: #ffff00;"></div>
                    <div class="color-btn" data-color="#ff6600" style="background: #ff6600;"></div>
                    <div class="color-btn" data-color="#ffffff" style="background: #ffffff;"></div>
                </div>
                <div class="slider-control">
                    <div class="slider-label">
                        <span>Pen Size</span>
                        <span class="slider-value" id="notes-pen-size-value">6</span>
                    </div>
                    <input type="range" id="notes-pen-size" min="2" max="20" value="6">
                </div>
                <button id="notes-tool-erase" style="background: var(--danger); border-color: var(--danger); margin: 8px 0;">ğŸ§¹ Toggle Erase Mode</button>
                <div id="notes-text-input" style="margin: 10px 0;">
                    <input type="text" id="notes-text" placeholder="Type your note..." style="width: 100%; padding: 8px; border-radius: 4px; font-size: 14px;">
                    <button id="notes-add-text" style="margin-top: 8px;">Add Text (at cursor)</button>
                </div>
                <button id="clear-notes-btn">Clear Notes</button>
                <button id="download-notes-btn" style="background: var(--accent-dim); border-color: var(--accent-bright); color: var(--accent-bright);">Download JPG</button>
                <div class="info">
                    <strong>Gestures:</strong><br>
                    â˜ï¸ <strong>Point (index only)</strong> = Draw<br>
                    âœ‹ <strong>Open hand</strong> = Pause/Move<br>
                    ğŸ§¹ Click button to toggle erase mode
                </div>
            </div>

            <h2>Settings</h2>
            <div class="slider-control">
                <div class="slider-label">
                    <span>Detection Confidence</span>
                    <span class="slider-value" id="detection-conf-value">0.75</span>
                </div>
                <input type="range" id="detection-conf" min="0.5" max="1.0" step="0.05" value="0.75">
            </div>
        </div>
    </div>

    <!-- Mobile Bottom Toolbar -->
    <div id="mobile-toolbar">
        <div class="toolbar-mode">
            <span class="toolbar-mode-icon" id="toolbar-mode-icon">ğŸ‘†</span>
            <span class="toolbar-mode-name" id="toolbar-mode-name">Tracking</span>
        </div>
        <button class="toolbar-btn" id="toolbar-camera" title="Toggle Camera">ğŸ“·</button>
        <button class="toolbar-btn" id="toolbar-menu" title="Open Menu">â˜°</button>
    </div>

    <!-- Mobile Menu Overlay -->
    <div id="mobile-overlay"></div>

    <!-- Mobile Slide-up Menu -->
    <div id="mobile-menu">
        <div class="menu-handle"></div>
        <div class="menu-content">
            <!-- Mode Selection Grid -->
            <div class="menu-section">
                <div class="menu-section-title">Select Mode</div>
                <div class="mobile-mode-grid">
                    <button class="mobile-mode-btn active" data-mode="tracking">
                        <span class="icon">ğŸ‘†</span>
                        Tracking
                    </button>
                    <button class="mobile-mode-btn" data-mode="particles">
                        <span class="icon">âœ¨</span>
                        Particles
                    </button>
                    <button class="mobile-mode-btn" data-mode="theremin">
                        <span class="icon">ğŸµ</span>
                        Theremin
                    </button>
                    <button class="mobile-mode-btn" data-mode="rps">
                        <span class="icon">âœŠ</span>
                        RPS Game
                    </button>
                    <button class="mobile-mode-btn" data-mode="drawing">
                        <span class="icon">ğŸ¨</span>
                        Air Draw
                    </button>
                    <button class="mobile-mode-btn" data-mode="notes">
                        <span class="icon">ğŸ“</span>
                        Notes
                    </button>
                </div>
            </div>

            <!-- Camera Control -->
            <div class="menu-section">
                <button class="menu-camera-btn" id="mobile-camera-btn">ğŸ“· Start Camera</button>
                <div class="menu-metrics">
                    <div class="menu-metric">
                        <span class="menu-metric-label">Hands</span>
                        <span class="menu-metric-value" id="mobile-hands">0</span>
                    </div>
                    <div class="menu-metric">
                        <span class="menu-metric-label">FPS</span>
                        <span class="menu-metric-value" id="mobile-fps">--</span>
                    </div>
                    <div class="menu-metric">
                        <span class="menu-metric-label">Gesture</span>
                        <span class="menu-metric-value" id="mobile-gesture">--</span>
                    </div>
                </div>
            </div>

            <!-- Mode-specific controls container -->
            <div class="menu-section" id="mobile-mode-controls-section">
                <!-- Dynamically populated based on current mode -->
            </div>
        </div>
    </div>

    <script type="module">
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CORE STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let video, canvas, ctx, hands, camera;
        let isRunning = false;
        let currentMode = 'tracking';
        let lastFrameTime = 0;
        let frameCount = 0;
        let fps = 0;

        // Hand landmark indices
        const WRIST = 0, THUMB_TIP = 4, INDEX_TIP = 8, MIDDLE_TIP = 12, RING_TIP = 16, PINKY_TIP = 20;
        const THUMB_MCP = 2, INDEX_MCP = 5, MIDDLE_MCP = 9, RING_MCP = 13, PINKY_MCP = 17;
        const FINGERTIPS = [THUMB_TIP, INDEX_TIP, MIDDLE_TIP, RING_TIP, PINKY_TIP];

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PARTICLE SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const MAX_PARTICLES = 200; // Strict limit
        let particles = [];
        let particleSettings = { count: 50, trailLength: 20 };
        let lastExplosionTime = 0;
        let lastSpawnTime = 0;
        let particleFrame = 0;

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 6;
                this.vy = (Math.random() - 0.5) * 6;
                this.life = 1.0;
                this.decay = 0.04 + Math.random() * 0.03; // Faster decay
                this.size = 2 + Math.random() * 4;
                this.color = color;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.15; // gravity
                this.vx *= 0.98; // friction
                this.vy *= 0.98;
                this.life -= this.decay;
            }
            draw(ctx) {
                if (this.life <= 0) return;
                const alpha = Math.floor(this.life * 255).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(this.x, this.y, Math.max(1, this.size * this.life), 0, Math.PI * 2);
                ctx.fillStyle = this.color + alpha;
                ctx.fill();
            }
        }

        function spawnParticles(x, y, count, color) {
            // Only spawn every 3rd frame and respect limit
            particleFrame++;
            if (particleFrame % 3 !== 0) return;
            if (particles.length >= MAX_PARTICLES) return;

            const toAdd = Math.min(count, MAX_PARTICLES - particles.length);
            for (let i = 0; i < toAdd; i++) {
                particles.push(new Particle(x, y, color));
            }
        }

        function explodeParticles(x, y) {
            const now = performance.now();
            if (now - lastExplosionTime < 1000) return; // 1 second cooldown
            if (particles.length >= MAX_PARTICLES - 20) return; // Need room
            lastExplosionTime = now;

            const maxExplosion = Math.min(30, MAX_PARTICLES - particles.length);
            for (let i = 0; i < maxExplosion; i++) {
                const p = new Particle(x, y, ['#00ffff', '#00ff88', '#ffff00', '#ff6600'][Math.floor(Math.random() * 4)]);
                p.vx = (Math.random() - 0.5) * 15;
                p.vy = (Math.random() - 0.5) * 15;
                p.size = 4 + Math.random() * 6;
                particles.push(p);
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // THEREMIN
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let audioCtx = null;
        let thereminOsc = null;
        let thereminGain = null;
        let thereminSettings = { minFreq: 100, maxFreq: 800 };
        let isThereminPlaying = false;
        let audioUnlocked = false;

        // iOS/Safari requires user interaction to unlock audio
        function unlockAudio() {
            if (audioUnlocked) return;
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    audioUnlocked = true;
                    console.log('Audio unlocked');
                    hideUnlockButton();
                });
            } else if (audioCtx && audioCtx.state === 'running') {
                audioUnlocked = true;
                hideUnlockButton();
            }
        }

        function showUnlockButton() {
            const btn = document.getElementById('unlock-audio-btn');
            if (btn && !audioUnlocked) {
                btn.style.display = 'block';
            }
        }

        function hideUnlockButton() {
            const btn = document.getElementById('unlock-audio-btn');
            if (btn) {
                btn.style.display = 'none';
            }
        }

        // Add touch/click handlers to unlock audio on iOS
        document.addEventListener('touchstart', unlockAudio, { once: false, passive: true });
        document.addEventListener('touchend', unlockAudio, { once: false, passive: true });
        document.addEventListener('click', unlockAudio, { once: false, passive: true });

        function initTheremin() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                // Try to resume immediately (may not work on iOS without gesture)
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
            }
            if (!thereminOsc) {
                thereminOsc = audioCtx.createOscillator();
                thereminGain = audioCtx.createGain();
                thereminOsc.connect(thereminGain);
                thereminGain.connect(audioCtx.destination);
                thereminOsc.type = 'sine';
                thereminOsc.frequency.value = 440;
                thereminGain.gain.value = 0;
                thereminOsc.start();
            }
            // Ensure audio is resumed
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
                // Show unlock button on iOS if audio is still suspended
                setTimeout(() => {
                    if (audioCtx.state === 'suspended') {
                        showUnlockButton();
                    }
                }, 100);
            } else {
                audioUnlocked = true;
                hideUnlockButton();
            }
        }

        // Unlock audio button click handler
        document.getElementById('unlock-audio-btn')?.addEventListener('click', function() {
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume().then(() => {
                    audioUnlocked = true;
                    hideUnlockButton();
                    // Re-init theremin to ensure it's working
                    initTheremin();
                });
            }
        });

        // Calculate hand openness (0 = closed/curled, 1 = fully open)
        function getHandOpenness(landmarks) {
            // Check how extended each finger is by comparing tip to knuckle (MCP)
            // When fingers are curled, tips are BELOW (higher Y) or AT the knuckles
            // When fingers are extended, tips are ABOVE (lower Y) the knuckles

            const mcps = [INDEX_MCP, MIDDLE_MCP, RING_MCP, PINKY_MCP];
            const tips = [INDEX_TIP, MIDDLE_TIP, RING_TIP, PINKY_TIP];

            let extendedCount = 0;
            let totalExtension = 0;

            for (let i = 0; i < 4; i++) {
                const tipY = landmarks[tips[i]].y;
                const mcpY = landmarks[mcps[i]].y;
                const wristY = landmarks[WRIST].y;

                // How far is the tip extended above the MCP relative to hand size
                // Negative = finger curled, Positive = finger extended
                const extension = mcpY - tipY;
                const handSize = wristY - mcpY; // Rough hand height

                if (handSize !== 0) {
                    const normalizedExt = extension / Math.abs(handSize);
                    // Finger is "extended" if tip is above MCP
                    if (normalizedExt > 0.1) {
                        extendedCount++;
                        totalExtension += Math.min(1, normalizedExt);
                    }
                }
            }

            // Return 0 if no fingers extended, scale based on how many and how much
            if (extendedCount === 0) return 0;
            return Math.min(1, (extendedCount / 4) * (totalExtension / extendedCount));
        }

        function updateThereminTwoHands(rightOpenness, leftOpenness, hasRightHand, hasLeftHand) {
            if (!thereminOsc) return;

            // Right hand controls pitch with threshold
            if (hasRightHand) {
                const threshold = 0.15;
                let freq = thereminSettings.minFreq;

                if (rightOpenness > threshold) {
                    // Scale remaining range to frequency
                    const scaled = (rightOpenness - threshold) / (1 - threshold);
                    const pitchNorm = Math.pow(scaled, 0.7); // Slight curve for smoother control
                    freq = thereminSettings.minFreq + (pitchNorm * (thereminSettings.maxFreq - thereminSettings.minFreq));
                }

                thereminOsc.frequency.setTargetAtTime(freq, audioCtx.currentTime, 0.02);
                document.getElementById('theremin-freq').textContent = Math.round(freq) + ' Hz';
            } else {
                document.getElementById('theremin-freq').textContent = 'No hand';
            }

            // Left hand controls volume with hard cutoff
            if (hasLeftHand) {
                // Threshold: below 0.25 openness = completely silent
                // Above 0.25, scale from 0 to max volume
                const threshold = 0.25;
                let vol = 0;
                if (leftOpenness > threshold) {
                    // Scale remaining range (0.25-1.0) to (0-0.5)
                    vol = ((leftOpenness - threshold) / (1 - threshold)) * 0.5;
                }
                thereminGain.gain.setTargetAtTime(vol, audioCtx.currentTime, 0.02);
                document.getElementById('theremin-vol').textContent = vol > 0 ? Math.round(vol * 200) + '%' : 'Muted';
                isThereminPlaying = vol > 0;
            } else {
                thereminGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05);
                document.getElementById('theremin-vol').textContent = 'No hand';
                isThereminPlaying = false;
            }
        }

        function stopTheremin() {
            if (thereminGain) {
                thereminGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.02);
            }
            document.getElementById('theremin-freq').textContent = '--';
            document.getElementById('theremin-vol').textContent = '--';
            isThereminPlaying = false;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ROCK PAPER SCISSORS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let rpsState = { wins: 0, ties: 0, losses: 0, playing: false, countdown: 0, result: '' };
        const RPS_MOVES = ['rock', 'paper', 'scissors'];
        const RPS_EMOJI = { rock: 'âœŠ', paper: 'âœ‹', scissors: 'âœŒï¸' };

        function detectRPSGesture(landmarks, fingerCount) {
            if (fingerCount === 0) return 'rock';
            if (fingerCount === 5) return 'paper';
            const indexUp = landmarks[INDEX_TIP].y < landmarks[INDEX_MCP].y;
            const middleUp = landmarks[MIDDLE_TIP].y < landmarks[MIDDLE_MCP].y;
            if (indexUp && middleUp && fingerCount === 2) return 'scissors';
            return null;
        }

        function playRPS(playerMove) {
            const computerMove = RPS_MOVES[Math.floor(Math.random() * 3)];
            document.getElementById('rps-your-move').textContent = RPS_EMOJI[playerMove];
            document.getElementById('rps-computer-move').textContent = RPS_EMOJI[computerMove];

            let result;
            if (playerMove === computerMove) {
                result = "It's a tie!";
                rpsState.ties++;
            } else if (
                (playerMove === 'rock' && computerMove === 'scissors') ||
                (playerMove === 'paper' && computerMove === 'rock') ||
                (playerMove === 'scissors' && computerMove === 'paper')
            ) {
                result = "You win!";
                rpsState.wins++;
            } else {
                result = "You lose!";
                rpsState.losses++;
            }
            document.getElementById('rps-result-text').textContent = result;
            document.getElementById('rps-wins').textContent = rpsState.wins;
            document.getElementById('rps-ties').textContent = rpsState.ties;
            document.getElementById('rps-losses').textContent = rpsState.losses;
            rpsState.playing = false;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AIR DRAWING
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let drawingCanvas, drawingCtx;
        let drawingColor = '#00ffff';
        let brushSize = 8;
        let lastDrawPoint = null;
        let isDrawing = false;

        function initDrawingCanvas() {
            drawingCanvas = document.createElement('canvas');
            drawingCtx = drawingCanvas.getContext('2d');
        }

        function clearDrawing() {
            if (drawingCtx) {
                drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            }
        }

        function drawLine(x1, y1, x2, y2, color, size) {
            drawingCtx.beginPath();
            drawingCtx.moveTo(x1, y1);
            drawingCtx.lineTo(x2, y2);
            drawingCtx.strokeStyle = color;
            drawingCtx.lineWidth = size;
            drawingCtx.lineCap = 'round';
            drawingCtx.stroke();
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // NOTES SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let notesCanvas, notesCtx;
        let notesColor = '#00ffff';
        let notesPenSize = 6;
        let lastNotesPoint = null;
        let notesTool = 'draw'; // draw, erase, pause - controlled by buttons
        let textPlacementPos = null;
        let lastNotesX = 0, lastNotesY = 0; // For text placement

        function initNotesCanvas() {
            notesCanvas = document.createElement('canvas');
            notesCtx = notesCanvas.getContext('2d');
        }

        function clearNotes() {
            if (notesCtx) {
                notesCtx.clearRect(0, 0, notesCanvas.width, notesCanvas.height);
            }
        }

        function downloadNotes() {
            if (!notesCanvas) return;
            // Create a temp canvas with white background + notes
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = notesCanvas.width || 1280;
            tempCanvas.height = notesCanvas.height || 720;
            const tempCtx = tempCanvas.getContext('2d');
            // White background
            tempCtx.fillStyle = '#ffffff';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            // Draw notes on top
            tempCtx.drawImage(notesCanvas, 0, 0);
            // Download
            const link = document.createElement('a');
            link.download = 'handtrack-notes-' + Date.now() + '.jpg';
            link.href = tempCanvas.toDataURL('image/jpeg', 0.9);
            link.click();
        }

        function notesDrawLine(x1, y1, x2, y2, color, size) {
            // Add glow effect
            notesCtx.shadowColor = color;
            notesCtx.shadowBlur = 15;
            notesCtx.shadowOffsetX = 0;
            notesCtx.shadowOffsetY = 0;

            notesCtx.beginPath();
            notesCtx.moveTo(x1, y1);
            notesCtx.lineTo(x2, y2);
            notesCtx.strokeStyle = color;
            notesCtx.lineWidth = size;
            notesCtx.lineCap = 'round';
            notesCtx.stroke();

            // Draw again without shadow for solid core
            notesCtx.shadowBlur = 0;
            notesCtx.stroke();
        }

        function notesErase(x, y, size) {
            if (notesCtx) {
                notesCtx.beginPath();
                notesCtx.arc(x, y, size * 4, 0, Math.PI * 2);
                notesCtx.globalCompositeOperation = 'destination-out';
                notesCtx.fill();
                notesCtx.globalCompositeOperation = 'source-over';
            }
        }

        function addTextToNotes(text, x, y) {
            if (notesCtx && text) {
                // Add glow to text
                notesCtx.shadowColor = notesColor;
                notesCtx.shadowBlur = 15;
                notesCtx.font = 'bold 28px sans-serif';
                notesCtx.fillStyle = notesColor;
                notesCtx.textAlign = 'center';
                notesCtx.fillText(text, x, y);

                // Draw again for solid core
                notesCtx.shadowBlur = 0;
                notesCtx.fillText(text, x, y);
            }
        }

        // Simple check - is index finger pointing up?
        function isIndexPointing(landmarks) {
            const indexUp = landmarks[INDEX_TIP].y < landmarks[INDEX_MCP].y;
            return indexUp;
        }

        // Is hand open (4+ fingers extended)?
        function isHandOpen(landmarks) {
            let extended = 0;
            if (landmarks[INDEX_TIP].y < landmarks[INDEX_MCP].y) extended++;
            if (landmarks[MIDDLE_TIP].y < landmarks[MIDDLE_MCP].y) extended++;
            if (landmarks[RING_TIP].y < landmarks[RING_MCP].y) extended++;
            if (landmarks[PINKY_TIP].y < landmarks[PINKY_MCP].y) extended++;
            return extended >= 3;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // HAND DETECTION HELPERS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function countExtendedFingers(landmarks, isRightHand) {
            let count = 0;
            // Thumb direction depends on which hand (after mirroring coordinates)
            // Right hand: thumb extends to the LEFT (tip.x < mcp.x)
            // Left hand: thumb extends to the RIGHT (tip.x > mcp.x)
            if (isRightHand) {
                if (landmarks[THUMB_TIP].x < landmarks[THUMB_MCP].x) count++;
            } else {
                if (landmarks[THUMB_TIP].x > landmarks[THUMB_MCP].x) count++;
            }
            // Other fingers: tip above (lower Y) than MCP = extended
            for (let i = 1; i < 5; i++) {
                if (landmarks[FINGERTIPS[i]].y < landmarks[[THUMB_MCP, INDEX_MCP, MIDDLE_MCP, RING_MCP, PINKY_MCP][i]].y) count++;
            }
            return count;
        }

        function detectGesture(landmarks, fingerCount) {
            const indexUp = landmarks[INDEX_TIP].y < landmarks[INDEX_MCP].y;
            const middleUp = landmarks[MIDDLE_TIP].y < landmarks[MIDDLE_MCP].y;
            const ringUp = landmarks[RING_TIP].y < landmarks[RING_MCP].y;
            const pinkyUp = landmarks[PINKY_TIP].y < landmarks[PINKY_MCP].y;
            const thumbUp = landmarks[THUMB_TIP].y < landmarks[THUMB_MCP].y;

            if (fingerCount === 0) return 'Fist';
            if (fingerCount === 5) return 'Open Palm';
            if (indexUp && !middleUp && !ringUp && !pinkyUp) return 'Pointing';
            if (indexUp && middleUp && !ringUp && !pinkyUp) return 'Peace';
            if (thumbUp && !indexUp && !middleUp && !ringUp && !pinkyUp) return 'Thumbs Up';
            if (indexUp && pinkyUp && !middleUp && !ringUp) return 'Rock On';

            // Pinch detection for drawing erase
            const thumbIndex = Math.hypot(
                landmarks[THUMB_TIP].x - landmarks[INDEX_TIP].x,
                landmarks[THUMB_TIP].y - landmarks[INDEX_TIP].y
            );
            if (thumbIndex < 0.05) return 'Pinch';

            return `${fingerCount} Fingers`;
        }

        function isPinching(landmarks) {
            const dist = Math.hypot(
                landmarks[THUMB_TIP].x - landmarks[INDEX_TIP].x,
                landmarks[THUMB_TIP].y - landmarks[INDEX_TIP].y
            );
            return dist < 0.05;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MAIN RENDER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function onResults(results) {
            // FPS counter
            frameCount++;
            const now = performance.now();
            if (now - lastFrameTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastFrameTime = now;
                document.getElementById('fps').textContent = fps;
            }

            const w = results.image.width;
            const h = results.image.height;
            canvas.width = w;
            canvas.height = h;

            // Sync drawing canvas size
            if (drawingCanvas && (drawingCanvas.width !== w || drawingCanvas.height !== h)) {
                const temp = drawingCtx.getImageData(0, 0, drawingCanvas.width, drawingCanvas.height);
                drawingCanvas.width = w;
                drawingCanvas.height = h;
                drawingCtx.putImageData(temp, 0, 0);
            }

            ctx.save();
            ctx.clearRect(0, 0, w, h);

            // Mirror the camera horizontally for natural interaction
            ctx.translate(w, 0);
            ctx.scale(-1, 1);

            // Draw camera feed (dimmed for some modes)
            if (currentMode === 'drawing' || currentMode === 'notes') {
                ctx.globalAlpha = 0.3;
            }
            ctx.drawImage(results.image, 0, 0, w, h);
            ctx.globalAlpha = 1.0;

            // Restore transform for drawing overlays (they use mirrored coords)
            ctx.setTransform(1, 0, 0, 1, 0, 0);

            // Sync notes canvas size
            if (notesCanvas && (notesCanvas.width !== w || notesCanvas.height !== h)) {
                const temp = notesCtx.getImageData(0, 0, notesCanvas.width, notesCanvas.height);
                notesCanvas.width = w;
                notesCanvas.height = h;
                notesCtx.putImageData(temp, 0, 0);
            }

            // Draw mode-specific overlays
            if (currentMode === 'drawing' && drawingCanvas) {
                ctx.drawImage(drawingCanvas, 0, 0);
            }

            if (currentMode === 'notes' && notesCanvas) {
                ctx.drawImage(notesCanvas, 0, 0);
            }

            // Update particles
            if (currentMode === 'particles') {
                particles = particles.filter(p => p.life > 0);
                particles.forEach(p => { p.update(); p.draw(ctx); });
            }

            // Process hands
            const numHands = results.multiHandLandmarks?.length || 0;
            document.getElementById('hands-count').textContent = numHands;

            if (results.multiHandLandmarks && results.multiHandedness) {
                for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                    const rawLandmarks = results.multiHandLandmarks[i];
                    // Mirror landmarks to match mirrored video
                    const landmarks = rawLandmarks.map(lm => ({ x: 1 - lm.x, y: lm.y, z: lm.z }));
                    const handedness = results.multiHandedness[i];
                    // MediaPipe returns handedness from camera's view, but we mirror the display
                    // So we need to swap: MediaPipe 'Left' = user's actual Right hand
                    const isRightHand = handedness.label === 'Left';
                    const fingerCount = countExtendedFingers(landmarks, isRightHand);
                    const gesture = detectGesture(landmarks, fingerCount);

                    if (i === 0) {
                        document.getElementById('gesture').textContent = gesture;
                    }

                    // Mode-specific logic
                    switch (currentMode) {
                        case 'tracking':
                            drawHandSkeleton(landmarks, isRightHand, w, h);
                            // Draw finger count on screen with glow
                            const handLabel = isRightHand ? 'R' : 'L';
                            const countX = isRightHand ? w - 100 : 100;
                            ctx.shadowColor = isRightHand ? '#00ff88' : '#00ffff';
                            ctx.shadowBlur = 20;
                            ctx.font = 'bold 72px Rajdhani, sans-serif';
                            ctx.fillStyle = isRightHand ? '#00ff88' : '#00ffff';
                            ctx.textAlign = 'center';
                            ctx.fillText(fingerCount, countX, 80);
                            ctx.font = 'bold 24px Rajdhani, sans-serif';
                            ctx.fillText(handLabel + ' hand', countX, 110);
                            ctx.shadowBlur = 0;
                            break;

                        case 'particles':
                            drawHandSkeleton(landmarks, isRightHand, w, h);
                            // Spawn particles at fingertips
                            for (const tip of FINGERTIPS) {
                                const x = landmarks[tip].x * w;
                                const y = landmarks[tip].y * h;
                                const colors = ['#00ffff', '#00ff88', '#ffff00', '#ff6600', '#ff44ff'];
                                spawnParticles(x, y, 2, colors[FINGERTIPS.indexOf(tip)]);
                            }
                            // Explosion on fist
                            if (gesture === 'Fist') {
                                const wristX = landmarks[WRIST].x * w;
                                const wristY = landmarks[WRIST].y * h;
                                explodeParticles(wristX, wristY);
                            }
                            break;

                        case 'theremin':
                            // Just draw skeleton here, actual theremin processing happens after the loop
                            drawHandSkeleton(landmarks, isRightHand, w, h);
                            break;

                        case 'rps':
                            drawHandSkeleton(landmarks, isRightHand, w, h);
                            if (rpsState.playing) {
                                const move = detectRPSGesture(landmarks, fingerCount);
                                if (move) {
                                    playRPS(move);
                                }
                            }
                            break;

                        case 'drawing':
                            const indexX = landmarks[INDEX_TIP].x * w;
                            const indexY = landmarks[INDEX_TIP].y * h;

                            // Draw cursor
                            ctx.beginPath();
                            ctx.arc(indexX, indexY, brushSize, 0, Math.PI * 2);
                            ctx.fillStyle = drawingColor + '88';
                            ctx.fill();
                            ctx.strokeStyle = '#fff';
                            ctx.lineWidth = 2;
                            ctx.stroke();

                            if (gesture === 'Pointing') {
                                // Draw
                                if (lastDrawPoint) {
                                    drawLine(lastDrawPoint.x, lastDrawPoint.y, indexX, indexY, drawingColor, brushSize);
                                }
                                lastDrawPoint = { x: indexX, y: indexY };
                            } else if (gesture === 'Pinch') {
                                // Erase
                                if (drawingCtx) {
                                    drawingCtx.beginPath();
                                    drawingCtx.arc(indexX, indexY, brushSize * 3, 0, Math.PI * 2);
                                    drawingCtx.fillStyle = '#000';
                                    drawingCtx.globalCompositeOperation = 'destination-out';
                                    drawingCtx.fill();
                                    drawingCtx.globalCompositeOperation = 'source-over';
                                }
                                lastDrawPoint = null;
                            } else {
                                lastDrawPoint = null;
                            }
                            break;

                        case 'notes':
                            const noteX = landmarks[INDEX_TIP].x * w;
                            const noteY = landmarks[INDEX_TIP].y * h;

                            // Store position for text placement
                            textPlacementPos = { x: noteX, y: noteY };

                            // Simple gesture detection:
                            // - Index pointing (other fingers down) = DRAW
                            // - Open hand (3+ fingers up) = PAUSE (move without drawing)
                            // - Button override for ERASE mode

                            const pointing = isIndexPointing(landmarks) && !isHandOpen(landmarks);
                            const openHand = isHandOpen(landmarks);

                            // Use button tool if set to erase, otherwise use gesture
                            const effectiveTool = notesTool === 'erase' ? 'erase' : (pointing ? 'draw' : 'pause');

                            if (effectiveTool === 'draw') {
                                // Draw mode - pen cursor with glow
                                ctx.shadowColor = notesColor;
                                ctx.shadowBlur = 20;
                                ctx.beginPath();
                                ctx.arc(noteX, noteY, notesPenSize, 0, Math.PI * 2);
                                ctx.fillStyle = notesColor;
                                ctx.fill();
                                ctx.shadowBlur = 0;

                                // Actually draw
                                if (lastNotesPoint) {
                                    notesDrawLine(lastNotesPoint.x, lastNotesPoint.y, noteX, noteY, notesColor, notesPenSize);
                                }
                                lastNotesPoint = { x: noteX, y: noteY };
                                document.getElementById('notes-mode').textContent = 'Drawing';

                            } else if (effectiveTool === 'erase') {
                                // Erase mode - eraser cursor with glow
                                ctx.shadowColor = '#ff4444';
                                ctx.shadowBlur = 25;
                                ctx.beginPath();
                                ctx.arc(noteX, noteY, notesPenSize * 4, 0, Math.PI * 2);
                                ctx.strokeStyle = '#ff4444';
                                ctx.lineWidth = 3;
                                ctx.stroke();
                                ctx.fillStyle = '#ff444444';
                                ctx.fill();
                                ctx.shadowBlur = 0;

                                // Actually erase
                                notesErase(noteX, noteY, notesPenSize);
                                lastNotesPoint = null;
                                document.getElementById('notes-mode').textContent = 'Erasing';

                            } else {
                                // Pause - show cursor with subtle glow
                                ctx.shadowColor = '#ffffff';
                                ctx.shadowBlur = 10;
                                ctx.beginPath();
                                ctx.arc(noteX, noteY, notesPenSize, 0, Math.PI * 2);
                                ctx.fillStyle = notesColor + '66';
                                ctx.fill();
                                ctx.strokeStyle = '#fff';
                                ctx.lineWidth = 1;
                                ctx.stroke();
                                ctx.shadowBlur = 0;
                                lastNotesPoint = null;
                                document.getElementById('notes-mode').textContent = 'Paused';
                            }

                            // Draw hand skeleton
                            drawHandSkeleton(landmarks, isRightHand, w, h);
                            break;
                    }
                }

                // Theremin: process both hands together after the loop
                if (currentMode === 'theremin') {
                    initTheremin();
                    let rightOpenness = 0, leftOpenness = 0;
                    let hasRight = false, hasLeft = false;

                    for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                        const rawLm = results.multiHandLandmarks[i];
                        const lm = rawLm.map(l => ({ x: 1 - l.x, y: l.y, z: l.z }));
                        const hand = results.multiHandedness[i];
                        // Swap handedness since we mirror the display
                        const isRight = hand.label === 'Left';

                        const openness = getHandOpenness(lm);

                        if (isRight) {
                            rightOpenness = openness;
                            hasRight = true;
                        } else {
                            leftOpenness = openness;
                            hasLeft = true;
                        }
                    }

                    updateThereminTwoHands(rightOpenness, leftOpenness, hasRight, hasLeft);
                }
            } else {
                document.getElementById('gesture').textContent = '--';
                lastDrawPoint = null;
                lastNotesPoint = null;
                // Stop theremin when no hand detected
                if (currentMode === 'theremin') {
                    stopTheremin();
                }
            }

            ctx.restore();
        }

        function drawHandSkeleton(landmarks, isRightHand, w, h) {
            const color = isRightHand ? '#00ff88' : '#00ffff';
            const connections = [
                [0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],
                [0,9],[9,10],[10,11],[11,12],[0,13],[13,14],[14,15],[15,16],
                [0,17],[17,18],[18,19],[19,20],[5,9],[9,13],[13,17]
            ];

            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            for (const [a, b] of connections) {
                ctx.beginPath();
                ctx.moveTo(landmarks[a].x * w, landmarks[a].y * h);
                ctx.lineTo(landmarks[b].x * w, landmarks[b].y * h);
                ctx.stroke();
            }

            for (let i = 0; i < landmarks.length; i++) {
                const x = landmarks[i].x * w;
                const y = landmarks[i].y * h;
                const isTip = FINGERTIPS.includes(i);
                ctx.beginPath();
                ctx.arc(x, y, isTip ? 8 : 5, 0, Math.PI * 2);
                ctx.fillStyle = isTip ? '#fff' : color;
                ctx.fill();
            }
        }


        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UI SETUP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        async function init() {
            console.log('Initializing...');

            video = document.createElement('video');
            video.autoplay = true;
            video.playsInline = true;
            video.muted = true;
            video.style.display = 'none';
            document.body.appendChild(video);

            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            initDrawingCanvas();
            initNotesCanvas();

            hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            hands.setOptions({
                maxNumHands: 2,
                modelComplexity: 1,
                minDetectionConfidence: 0.75,
                minTrackingConfidence: 0.5
            });
            hands.onResults(onResults);

            // Mode selector
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Stop theremin when switching away from it
                    if (currentMode === 'theremin') {
                        stopTheremin();
                    }

                    currentMode = btn.dataset.mode;

                    document.querySelectorAll('.mode-info').forEach(info => info.classList.remove('active'));
                    document.getElementById(`info-${currentMode}`).classList.add('active');

                    // Reset mode-specific state
                    particles = [];
                    lastDrawPoint = null;
                });
            });

            // Camera button
            document.getElementById('camera-btn').addEventListener('click', toggleCamera);

            // Sliders
            document.getElementById('detection-conf').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                document.getElementById('detection-conf-value').textContent = val.toFixed(2);
                hands.setOptions({ minDetectionConfidence: val, minTrackingConfidence: val - 0.15 });
            });

            document.getElementById('particle-count').addEventListener('input', (e) => {
                particleSettings.count = parseInt(e.target.value);
                document.getElementById('particle-count-value').textContent = e.target.value;
            });

            document.getElementById('trail-length').addEventListener('input', (e) => {
                particleSettings.trailLength = parseInt(e.target.value);
                document.getElementById('trail-length-value').textContent = e.target.value;
            });

            document.getElementById('brush-size').addEventListener('input', (e) => {
                brushSize = parseInt(e.target.value);
                document.getElementById('brush-size-value').textContent = e.target.value;
            });

            // Theremin sliders
            document.getElementById('min-freq').addEventListener('input', (e) => {
                thereminSettings.minFreq = parseInt(e.target.value);
                document.getElementById('min-freq-value').textContent = e.target.value;
            });

            document.getElementById('max-freq').addEventListener('input', (e) => {
                thereminSettings.maxFreq = parseInt(e.target.value);
                document.getElementById('max-freq-value').textContent = e.target.value;
            });

            // Color picker
            document.querySelectorAll('.color-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    drawingColor = btn.dataset.color;
                });
            });

            // Clear drawing
            document.getElementById('clear-drawing-btn').addEventListener('click', clearDrawing);

            // RPS play button
            document.getElementById('rps-play-btn').addEventListener('click', () => {
                rpsState.playing = true;
                document.getElementById('rps-result-text').textContent = 'Show Rock, Paper, or Scissors!';
                document.getElementById('rps-your-move').textContent = '?';
                document.getElementById('rps-computer-move').textContent = '?';
            });

            // Notes controls
            document.getElementById('notes-pen-size').addEventListener('input', (e) => {
                notesPenSize = parseInt(e.target.value);
                document.getElementById('notes-pen-size-value').textContent = e.target.value;
            });

            document.querySelectorAll('#notes-colors .color-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#notes-colors .color-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    notesColor = btn.dataset.color;
                });
            });

            document.getElementById('clear-notes-btn').addEventListener('click', clearNotes);
            document.getElementById('download-notes-btn').addEventListener('click', downloadNotes);

            // Erase button - toggle between draw and erase mode
            const eraseBtn = document.getElementById('notes-tool-erase');
            eraseBtn.addEventListener('click', () => {
                if (notesTool === 'erase') {
                    notesTool = 'draw';
                    lastNotesPoint = null;
                    eraseBtn.style.background = 'var(--danger)';
                    eraseBtn.style.borderColor = 'var(--danger)';
                    eraseBtn.textContent = 'ğŸ§¹ Toggle Erase Mode';
                } else {
                    notesTool = 'erase';
                    lastNotesPoint = null;
                    eraseBtn.style.background = '#ff0000';
                    eraseBtn.style.borderColor = '#ff0000';
                    eraseBtn.style.boxShadow = '0 0 20px rgba(255,0,0,0.5)';
                    eraseBtn.textContent = 'ğŸ§¹ ERASE MODE ON';
                }
            });

            document.getElementById('notes-add-text').addEventListener('click', () => {
                const text = document.getElementById('notes-text').value;
                if (text && textPlacementPos) {
                    addTextToNotes(text, textPlacementPos.x, textPlacementPos.y);
                    document.getElementById('notes-text').value = '';
                }
            });

            document.getElementById('notes-text').addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    document.getElementById('notes-add-text').click();
                }
            });

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // MOBILE MENU CONTROLS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const mobileMenu = document.getElementById('mobile-menu');
            const mobileOverlay = document.getElementById('mobile-overlay');
            const toolbarMenu = document.getElementById('toolbar-menu');
            const toolbarCamera = document.getElementById('toolbar-camera');

            const modeIcons = {
                'tracking': 'ğŸ‘†',
                'particles': 'âœ¨',
                'theremin': 'ğŸµ',
                'rps': 'âœŠ',
                'drawing': 'ğŸ¨',
                'notes': 'ğŸ“'
            };

            const modeNames = {
                'tracking': 'Tracking',
                'particles': 'Particles',
                'theremin': 'Theremin',
                'rps': 'RPS Game',
                'drawing': 'Air Draw',
                'notes': 'Notes'
            };

            function openMobileMenu() {
                mobileMenu.classList.add('open');
                mobileOverlay.classList.add('visible');
                toolbarMenu.classList.add('active');
            }

            function closeMobileMenu() {
                mobileMenu.classList.remove('open');
                mobileOverlay.classList.remove('visible');
                toolbarMenu.classList.remove('active');
            }

            function updateMobileToolbar() {
                document.getElementById('toolbar-mode-icon').textContent = modeIcons[currentMode];
                document.getElementById('toolbar-mode-name').textContent = modeNames[currentMode];

                // Update camera button state
                if (isRunning) {
                    toolbarCamera.classList.add('camera-on');
                } else {
                    toolbarCamera.classList.remove('camera-on');
                }
            }

            // Menu toggle
            if (toolbarMenu) {
                toolbarMenu.addEventListener('click', () => {
                    if (mobileMenu.classList.contains('open')) {
                        closeMobileMenu();
                    } else {
                        openMobileMenu();
                    }
                });
            }

            // Overlay click to close
            if (mobileOverlay) {
                mobileOverlay.addEventListener('click', closeMobileMenu);
            }

            // Toolbar camera button
            if (toolbarCamera) {
                toolbarCamera.addEventListener('click', toggleCamera);
            }

            // Mobile camera button in menu
            const mobileCameraBtn = document.getElementById('mobile-camera-btn');
            if (mobileCameraBtn) {
                mobileCameraBtn.addEventListener('click', toggleCamera);
            }

            // Mobile mode selection
            document.querySelectorAll('.mobile-mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    // Update mobile mode buttons
                    document.querySelectorAll('.mobile-mode-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');

                    // Also update desktop buttons
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    const desktopBtn = document.querySelector(`.mode-btn[data-mode="${btn.dataset.mode}"]`);
                    if (desktopBtn) desktopBtn.classList.add('active');

                    // Stop theremin when switching away
                    if (currentMode === 'theremin') {
                        stopTheremin();
                    }

                    currentMode = btn.dataset.mode;

                    // Update mode info panels
                    document.querySelectorAll('.mode-info').forEach(info => info.classList.remove('active'));
                    document.getElementById(`info-${currentMode}`).classList.add('active');

                    // Reset state
                    particles = [];
                    lastDrawPoint = null;

                    // Update toolbar
                    updateMobileToolbar();

                    // Close menu after selection
                    closeMobileMenu();
                });
            });

            // Update mobile metrics periodically
            setInterval(() => {
                const mobileHands = document.getElementById('mobile-hands');
                const mobileFps = document.getElementById('mobile-fps');
                const mobileGesture = document.getElementById('mobile-gesture');
                const handCount = document.getElementById('hand-count');
                const fpsDisplay = document.getElementById('fps-display');
                const gestureDisplay = document.getElementById('gesture-display');

                if (mobileHands && handCount) mobileHands.textContent = handCount.textContent;
                if (mobileFps && fpsDisplay) mobileFps.textContent = fpsDisplay.textContent;
                if (mobileGesture && gestureDisplay) mobileGesture.textContent = gestureDisplay.textContent;
            }, 200);

            console.log('Initialized');
        }

        async function toggleCamera() {
            const cameraBtn = document.getElementById('camera-btn');
            const statusIndicator = document.getElementById('camera-status');
            const statusText = document.getElementById('camera-status-text');
            const noCamera = document.getElementById('no-camera');
            const toolbarCamera = document.getElementById('toolbar-camera');
            const mobileCameraBtn = document.getElementById('mobile-camera-btn');

            // Resume AudioContext on iOS (requires user gesture)
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }

            if (isRunning) {
                if (camera) { camera.stop(); camera = null; }
                isRunning = false;
                cameraBtn.textContent = 'Start Camera';
                statusIndicator.classList.replace('active', 'inactive');
                statusText.textContent = 'Off';
                noCamera.style.display = 'block';
                canvas.style.display = 'none';

                // Update mobile UI
                if (toolbarCamera) toolbarCamera.classList.remove('camera-on');
                if (mobileCameraBtn) {
                    mobileCameraBtn.textContent = 'ğŸ“· Start Camera';
                    mobileCameraBtn.classList.remove('active');
                }
            } else {
                try {
                    cameraBtn.disabled = true;
                    cameraBtn.textContent = 'Loading ML Model...';
                    statusText.textContent = 'Loading...';
                    if (mobileCameraBtn) mobileCameraBtn.textContent = 'â³ Loading...';

                    camera = new Camera(video, {
                        onFrame: async () => { if (isRunning) await hands.send({ image: video }); },
                        width: 1280,
                        height: 720,
                        facingMode: 'user' // Front camera on mobile
                    });

                    await camera.start();
                    isRunning = true;

                    cameraBtn.textContent = 'Stop Camera';
                    cameraBtn.disabled = false;
                    statusIndicator.classList.replace('inactive', 'active');
                    statusText.textContent = 'On';
                    noCamera.style.display = 'none';
                    canvas.style.display = 'block';

                    // Update mobile UI
                    if (toolbarCamera) toolbarCamera.classList.add('camera-on');
                    if (mobileCameraBtn) {
                        mobileCameraBtn.textContent = 'ğŸ›‘ Stop Camera';
                        mobileCameraBtn.classList.add('active');
                    }
                } catch (err) {
                    console.error('Camera error:', err);
                    alert('Failed to start camera: ' + err.message);
                    cameraBtn.textContent = 'Start Camera';
                    cameraBtn.disabled = false;
                    statusText.textContent = 'Error';
                    if (mobileCameraBtn) mobileCameraBtn.textContent = 'ğŸ“· Start Camera';
                }
            }
        }

        init();
    </script>
</body>
</html>
