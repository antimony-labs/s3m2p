//! â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//! FILE: github.rs | DNA/CLAUDE_AUTOMATION/src/github.rs
//! PURPOSE: Defines Issue, Comment, GitHubClient types
//! MODIFIED: 2025-12-09
//! LAYER: DNA (foundation)
//! â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

use crate::config::Config;
use anyhow::Result;
use octocrab::Octocrab;
use serde::{Deserialize, Serialize};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Issue {
    pub number: u64,
    pub title: String,
    pub body: Option<String>,
    pub labels: Vec<String>,
    pub state: String,
    pub created_at: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Comment {
    pub id: u64,
    pub issue_number: u64,
    pub user: String,
    pub body: String,
    pub created_at: String,
    pub updated_at: String,
}

pub struct GitHubClient {
    client: Octocrab,
    owner: String,
    repo: String,
    auto_label: String,
    trigger_pattern: String,
}

impl GitHubClient {
    pub fn new(config: &Config) -> Result<Self> {
        let token = std::env::var("GITHUB_TOKEN")?;
        let client = Octocrab::builder().personal_token(token).build()?;

        Ok(Self {
            client,
            owner: config.github.owner.clone(),
            repo: config.github.repo.clone(),
            auto_label: config.github.auto_label.clone(),
            trigger_pattern: config.github.trigger_pattern.clone(),
        })
    }

    /// Poll for issues labeled with claude-auto that need automation
    pub async fn poll_triggers(&self) -> Result<Vec<Issue>> {
        let issues = self
            .client
            .issues(&self.owner, &self.repo)
            .list()
            .state(octocrab::params::State::Open)
            .labels(std::slice::from_ref(&self.auto_label))
            .per_page(20)
            .send()
            .await?;

        let mut result = Vec::new();
        for issue in issues.items {
            // Check if there's a CLAUDE_TRIGGER comment
            let comments = self
                .client
                .issues(&self.owner, &self.repo)
                .list_comments(issue.number)
                .per_page(100)
                .send()
                .await?;

            let has_trigger = comments.items.iter().any(|c| {
                c.body
                    .as_ref()
                    .is_some_and(|b| b.contains(&self.trigger_pattern))
            });

            if has_trigger {
                result.push(Issue {
                    number: issue.number,
                    title: issue.title.clone(),
                    body: issue.body.clone(),
                    labels: issue.labels.iter().map(|l| l.name.clone()).collect(),
                    state: format!("{:?}", issue.state),
                    created_at: issue.created_at.to_string(),
                });
            }
        }

        Ok(result)
    }

    /// Get comments on a PR
    pub async fn get_pr_comments(
        &self,
        pr_number: u64,
        since: Option<String>,
    ) -> Result<Vec<Comment>> {
        let _pr = self
            .client
            .pulls(&self.owner, &self.repo)
            .get(pr_number)
            .await?;

        // Get both review comments and issue comments (PRs are also issues)
        let comments = self
            .client
            .issues(&self.owner, &self.repo)
            .list_comments(pr_number)
            .per_page(100)
            .send()
            .await?;

        let mut result = Vec::new();
        for comment in comments.items {
            // Filter by timestamp
            if let Some(ref since_time) = since {
                if comment.created_at.to_string() <= *since_time {
                    continue;
                }
            }

            // Skip bot comments
            if let Some(ref body) = comment.body {
                if body.contains("Generated by Claude")
                    || body.starts_with("ğŸ”§")
                    || body.starts_with("âœ…")
                {
                    continue;
                }
            }

            result.push(Comment {
                id: comment.id.0,
                issue_number: pr_number,
                user: comment.user.login.clone(),
                body: comment.body.clone().unwrap_or_default(),
                created_at: comment.created_at.to_string(),
                updated_at: comment
                    .updated_at
                    .map(|t| t.to_string())
                    .unwrap_or_else(|| comment.created_at.to_string()),
            });
        }

        Ok(result)
    }

    /// Get new comments on an issue since a given timestamp
    pub async fn get_new_comments(
        &self,
        issue_number: u64,
        since: Option<String>,
    ) -> Result<Vec<Comment>> {
        let comments = self
            .client
            .issues(&self.owner, &self.repo)
            .list_comments(issue_number)
            .per_page(100)
            .send()
            .await?;

        let mut result = Vec::new();
        for comment in comments.items {
            // Filter by timestamp if provided
            if let Some(ref since_time) = since {
                if comment.created_at.to_string() <= *since_time {
                    continue;
                }
            }

            // Skip bot comments and agent responses
            if let Some(ref body) = comment.body {
                // Skip CLAUDE_TRIGGER comments
                if body.contains(&self.trigger_pattern) {
                    continue;
                }
                // Skip ALL comments that contain Claude's signature
                if body.contains("Generated by Claude Automation")
                    || body.contains("Claude Automation (Planner Agent)")
                    || body.contains("Claude Automation (Executor Agent)")
                    || body.starts_with("ğŸ”")
                    || body.starts_with("ğŸ”§")
                    || body.starts_with("âœ…")
                    || body.starts_with("ğŸ“‹")
                    || body.starts_with("##")
                {
                    // Agent responses often start with markdown headers
                    continue;
                }
            }

            // Skip comments from the repo owner if they're automated
            if comment.user.login == self.owner {
                if let Some(ref body) = comment.body {
                    if body.contains("ğŸ¤–") || body.contains("*Generated by Claude") {
                        continue;
                    }
                }
            }

            result.push(Comment {
                id: comment.id.0,
                issue_number,
                user: comment.user.login.clone(),
                body: comment.body.clone().unwrap_or_default(),
                created_at: comment.created_at.to_string(),
                updated_at: comment
                    .updated_at
                    .map(|t| t.to_string())
                    .unwrap_or_else(|| comment.created_at.to_string()),
            });
        }

        Ok(result)
    }

    /// Get open PRs for automation issues
    pub async fn get_automation_prs(&self) -> Result<Vec<(u64, u64)>> {
        // Returns (pr_number, issue_number) pairs
        let prs = self
            .client
            .pulls(&self.owner, &self.repo)
            .list()
            .state(octocrab::params::State::Open)
            .per_page(50)
            .send()
            .await?;

        let mut result = Vec::new();
        let re = regex::Regex::new(r"(?:Closes|Implements|Fixes)\s+#(\d+)").unwrap();
        for pr in prs.items {
            // Check if PR body contains "Closes #" or "Implements #"
            if let Some(ref body) = pr.body {
                // Extract issue number from PR body
                if let Some(cap) = re.captures(body) {
                    if let Some(issue_num) = cap.get(1) {
                        if let Ok(num) = issue_num.as_str().parse::<u64>() {
                            result.push((pr.number, num));
                        }
                    }
                }
            }
        }

        Ok(result)
    }
}
