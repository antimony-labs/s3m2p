//! â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//! FILE: webhook.rs | DNA/CLAUDE_AUTOMATION/src/webhook.rs
//! PURPOSE: Defines AppState, WebhookPayload types
//! MODIFIED: 2025-12-02
//! LAYER: DNA (foundation)
//! â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

use axum::{
    extract::State,
    http::StatusCode,
    response::IntoResponse,
    Json,
};
use serde::Deserialize;
use std::sync::Arc;
use std::collections::HashMap;
use std::time::Instant;
use tokio::sync::Mutex;
use tracing::{info, warn, error};
use crate::config::Config;
use crate::state::Database;
use crate::{agent_router, session};
use crate::agent_router::Agent;

/// Cooldown period between spawns for the same issue (60 seconds)
const SPAWN_COOLDOWN_SECS: u64 = 60;

#[derive(Clone)]
pub struct AppState {
    pub config: Arc<Config>,
    pub db: Arc<Database>,
    /// Track last spawn time per issue to prevent rapid re-spawning
    pub last_spawn: Arc<Mutex<HashMap<u64, Instant>>>,
}

#[derive(Deserialize, Debug)]
pub struct WebhookPayload {
    pub action: String,
    pub issue: Option<serde_json::Value>,
    pub comment: Option<serde_json::Value>,
    pub label: Option<serde_json::Value>,
}

pub async fn handler(
    State(state): State<AppState>,
    Json(payload): Json<WebhookPayload>,
) -> impl IntoResponse {
    // Helper structs for internal parsing
    #[derive(Deserialize)]
    struct LocalLabel { name: String }
    #[derive(Deserialize)]
    struct LocalUser { login: String }
    #[derive(Deserialize)]
    struct LocalIssue {
        number: u64,
        title: String,
        body: Option<String>,
        labels: Vec<LocalLabel>,
        state: String,
        created_at: String,
    }
    #[derive(Deserialize)]
    struct LocalComment {
        id: u64,
        body: String,
        user: LocalUser,
        created_at: String,
        updated_at: String,
    }

    if payload.action == "labeled" {
        if let (Some(issue_json), Some(label_json)) = (payload.issue, payload.label) {
            let issue: LocalIssue = match serde_json::from_value(issue_json) {
                Ok(i) => i,
                Err(e) => {
                    error!("Failed to parse issue: {}", e);
                    return StatusCode::BAD_REQUEST;
                }
            };
            let label: LocalLabel = match serde_json::from_value(label_json) {
                Ok(l) => l,
                Err(e) => {
                    error!("Failed to parse label: {}", e);
                    return StatusCode::BAD_REQUEST;
                }
            };

            if label.name == "claude-auto" {
                info!("Webhook: Issue #{} labeled 'claude-auto'", issue.number);

                if state.db.automation_exists(issue.number).unwrap_or(false) {
                    info!("Automation already exists for issue #{}", issue.number);
                    return StatusCode::OK;
                }

                let internal_issue = crate::github::Issue {
                    number: issue.number,
                    title: issue.title,
                    body: issue.body,
                    labels: issue.labels.into_iter().map(|l| l.name).collect(),
                    state: issue.state,
                    created_at: issue.created_at,
                };

                info!("Spawning Planner for issue #{}", internal_issue.number);
                if let Err(e) = session::spawn_planner(&internal_issue, &state.config, &state.db).await {
                    error!("Failed to spawn Planner: {}", e);
                    return StatusCode::INTERNAL_SERVER_ERROR;
                }
            }
        }
    } else if payload.action == "created" {
        if let (Some(issue_json), Some(comment_json)) = (payload.issue, payload.comment) {
             let issue: LocalIssue = match serde_json::from_value(issue_json) {
                Ok(i) => i,
                Err(e) => {
                    error!("Failed to parse issue: {}", e);
                    return StatusCode::BAD_REQUEST;
                }
            };
            let comment: LocalComment = match serde_json::from_value(comment_json) {
                Ok(c) => c,
                Err(e) => {
                    error!("Failed to parse comment: {}", e);
                    return StatusCode::BAD_REQUEST;
                }
            };

            // Filter out bot comments and agent-generated comments
            if comment.user.login.ends_with("[bot]") || comment.user.login == "github-actions" {
                info!("Webhook: Ignoring bot comment on issue #{}", issue.number);
                return StatusCode::OK;
            }

            // Filter out comments generated by our automation (contain signature)
            if comment.body.contains("Generated with [Claude Code]")
                || comment.body.contains("Generated with Claude Code")
                || comment.body.contains("ğŸ¤– Generated with")
                || comment.body.contains("Co-Authored-By: Claude") {
                info!("Webhook: Ignoring agent-generated comment on issue #{}", issue.number);
                return StatusCode::OK;
            }

            info!("Webhook: New comment on issue #{} by {}", issue.number, comment.user.login);

            if !state.db.automation_exists(issue.number).unwrap_or(false) {
                return StatusCode::OK;
            }

            let internal_comment = crate::github::Comment {
                id: comment.id,
                issue_number: issue.number,
                user: comment.user.login,
                body: comment.body,
                created_at: comment.created_at,
                updated_at: comment.updated_at,
            };

            if let Err(e) = state.db.add_comments(issue.number, &[internal_comment.clone()]) {
                error!("Failed to add comment to DB: {}", e);
                return StatusCode::INTERNAL_SERVER_ERROR;
            }

            if let Ok(pids) = state.db.get_active_pids() {
                if pids.iter().any(|(id, _)| *id == issue.number) {
                    warn!("Agent already running for issue #{}, skipping spawn", issue.number);
                    return StatusCode::OK;
                }
            }

            // Check cooldown to prevent rapid re-spawning (race condition protection)
            {
                let last_spawn = state.last_spawn.lock().await;
                if let Some(last_time) = last_spawn.get(&issue.number) {
                    let elapsed = last_time.elapsed().as_secs();
                    if elapsed < SPAWN_COOLDOWN_SECS {
                        warn!("Spawn cooldown active for issue #{} ({}/{}s), skipping",
                              issue.number, elapsed, SPAWN_COOLDOWN_SECS);
                        return StatusCode::OK;
                    }
                }
            }

            match agent_router::decide(&[internal_comment], &state.db) {
                Ok(agent) => {
                    // Record spawn time BEFORE spawning to prevent race conditions
                    {
                        let mut last_spawn = state.last_spawn.lock().await;
                        last_spawn.insert(issue.number, Instant::now());
                    }

                    let spawn_result = match agent {
                        Agent::Planner => {
                            info!("Webhook: Spawning Planner for issue #{}", issue.number);
                            session::spawn_planner_with_context(issue.number, &state.config, &state.db).await
                        }
                        Agent::Executor => {
                            info!("Webhook: Spawning Executor for issue #{}", issue.number);
                            session::spawn_executor(issue.number, &state.config, &state.db).await
                        }
                    };

                    if let Err(e) = spawn_result {
                        error!("Failed to spawn agent: {}", e);
                        return StatusCode::INTERNAL_SERVER_ERROR;
                    }
                }
                Err(e) => {
                    error!("Router failed: {}", e);
                    return StatusCode::INTERNAL_SERVER_ERROR;
                }
            }
        }
    } else {
        warn!("Webhook: Ignored action: {}", payload.action);
    }

    StatusCode::OK
}

#[cfg(test)]
mod tests {
    use super::*;
    use serde_json::json;

    #[test]
    fn test_deserialize_issue_labeled() {
        let payload = json!({
            "action": "labeled",
            "issue": {
                "number": 1,
                "title": "Test Issue",
                "body": "Body",
                "labels": [{"name": "claude-auto"}],
                "state": "open",
                "created_at": "2023-01-01T00:00:00Z",
                "user": { "login": "user" }
            },
            "label": {
                "name": "claude-auto"
            }
        });

        let event: WebhookPayload = serde_json::from_value(payload).expect("Failed to deserialize");
        assert_eq!(event.action, "labeled");
        assert!(event.issue.is_some());
        assert!(event.label.is_some());
    }

    #[test]
    fn test_deserialize_issue_comment_created() {
        let payload = json!({
            "action": "created",
            "issue": {
                "number": 1,
                "title": "Test Issue",
                "body": "Body",
                "labels": [],
                "state": "open",
                "created_at": "2023-01-01T00:00:00Z",
                "user": { "login": "user" }
            },
            "comment": {
                "id": 123,
                "body": "execute",
                "user": { "login": "commenter" },
                "created_at": "2023-01-01T00:00:00Z",
                "updated_at": "2023-01-01T00:00:00Z"
            }
        });

        let event: WebhookPayload = serde_json::from_value(payload).expect("Failed to deserialize");
        assert_eq!(event.action, "created");
        assert!(event.issue.is_some());
        assert!(event.comment.is_some());
    }

    #[test]
    fn test_deserialize_unknown_action() {
        let payload = json!({
            "action": "deleted",
            "issue": {
                "number": 1,
                "title": "Test Issue",
                "body": "Body",
                "labels": [],
                "state": "open",
                "created_at": "2023-01-01T00:00:00Z",
                "user": { "login": "user" }
            }
        });

        let event: WebhookPayload = serde_json::from_value(payload).expect("Failed to deserialize");
        assert_eq!(event.action, "deleted");
    }
}
