//! ═══════════════════════════════════════════════════════════════════════════════
//! FILE: stl.rs | DNA/src/export/stl.rs
//! PURPOSE: STL (STereoLithography) file export for 3D printing
//! MODIFIED: 2026-01-04
//! LAYER: DNA (foundation)
//! ═══════════════════════════════════════════════════════════════════════════════

use crate::cad::mesh::TriangleMesh;

/// Export mesh to binary STL format
///
/// Binary STL format:
/// - 80 byte header (ASCII text, typically file description)
/// - 4 byte unsigned int (little-endian): triangle count
/// - For each triangle (50 bytes):
///   - 3 floats (12 bytes): normal vector (x, y, z)
///   - 3 floats (12 bytes): vertex 1 (x, y, z)
///   - 3 floats (12 bytes): vertex 2 (x, y, z)
///   - 3 floats (12 bytes): vertex 3 (x, y, z)
///   - 2 bytes: attribute byte count (usually 0)
pub fn write_stl_binary(mesh: &TriangleMesh, name: &str) -> Vec<u8> {
    let mut data = Vec::new();

    // 80-byte header
    let header = format!("Binary STL generated by Antimony Labs MCAD - {}", name);
    let mut header_bytes = header.as_bytes().to_vec();
    header_bytes.resize(80, 0);
    data.extend_from_slice(&header_bytes);

    // Triangle count (4 bytes, little-endian)
    let tri_count = mesh.triangles.len() as u32;
    data.extend_from_slice(&tri_count.to_le_bytes());

    // Write each triangle
    for (i, tri) in mesh.triangles.iter().enumerate() {
        let normal = &mesh.normals[i];
        let v0 = &mesh.vertices[tri[0]];
        let v1 = &mesh.vertices[tri[1]];
        let v2 = &mesh.vertices[tri[2]];

        // Normal (3 floats)
        data.extend_from_slice(&normal.x.to_le_bytes());
        data.extend_from_slice(&normal.y.to_le_bytes());
        data.extend_from_slice(&normal.z.to_le_bytes());

        // Vertex 0
        data.extend_from_slice(&v0.x.to_le_bytes());
        data.extend_from_slice(&v0.y.to_le_bytes());
        data.extend_from_slice(&v0.z.to_le_bytes());

        // Vertex 1
        data.extend_from_slice(&v1.x.to_le_bytes());
        data.extend_from_slice(&v1.y.to_le_bytes());
        data.extend_from_slice(&v1.z.to_le_bytes());

        // Vertex 2
        data.extend_from_slice(&v2.x.to_le_bytes());
        data.extend_from_slice(&v2.y.to_le_bytes());
        data.extend_from_slice(&v2.z.to_le_bytes());

        // Attribute byte count (2 bytes)
        data.extend_from_slice(&0u16.to_le_bytes());
    }

    data
}

/// Export mesh to ASCII STL format (for debugging)
pub fn write_stl_ascii(mesh: &TriangleMesh, name: &str) -> String {
    let mut output = String::new();

    output.push_str(&format!("solid {}\n", name));

    for (i, tri) in mesh.triangles.iter().enumerate() {
        let normal = &mesh.normals[i];
        let v0 = &mesh.vertices[tri[0]];
        let v1 = &mesh.vertices[tri[1]];
        let v2 = &mesh.vertices[tri[2]];

        output.push_str(&format!(
            "  facet normal {} {} {}\n",
            normal.x, normal.y, normal.z
        ));
        output.push_str("    outer loop\n");
        output.push_str(&format!("      vertex {} {} {}\n", v0.x, v0.y, v0.z));
        output.push_str(&format!("      vertex {} {} {}\n", v1.x, v1.y, v1.z));
        output.push_str(&format!("      vertex {} {} {}\n", v2.x, v2.y, v2.z));
        output.push_str("    endloop\n");
        output.push_str("  endfacet\n");
    }

    output.push_str(&format!("endsolid {}\n", name));

    output
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::cad::{mesh::solid_to_mesh, primitives::make_box};

    #[test]
    fn test_binary_stl_format() {
        let solid = make_box(10.0, 10.0, 10.0);
        let mesh = solid_to_mesh(&solid);
        let binary = write_stl_binary(&mesh, "test_box");

        // Check header (80 bytes) + count (4 bytes)
        assert!(binary.len() >= 84);

        // Check triangle count
        let tri_count = u32::from_le_bytes([binary[80], binary[81], binary[82], binary[83]]);
        assert_eq!(tri_count as usize, mesh.triangles.len());

        // Check total size: 80 + 4 + (50 * triangle_count)
        assert_eq!(binary.len(), 84 + 50 * mesh.triangles.len());
    }

    #[test]
    fn test_ascii_stl_format() {
        let solid = make_box(5.0, 5.0, 5.0);
        let mesh = solid_to_mesh(&solid);
        let ascii = write_stl_ascii(&mesh, "test_box");

        assert!(ascii.starts_with("solid test_box"));
        assert!(ascii.contains("facet normal"));
        assert!(ascii.contains("outer loop"));
        assert!(ascii.contains("vertex"));
        assert!(ascii.ends_with("endsolid test_box\n"));
    }
}
