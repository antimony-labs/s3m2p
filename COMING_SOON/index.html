<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coming Soon | too.foo</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%;
      height: 100%;
      background: #050508;
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
      overflow: hidden;
      color: #e0e0e0;
    }

    .container {
      display: flex;
      width: 100%;
      height: 100%;
      position: relative;
    }

    .message-panel {
      position: absolute;
      left: 0;
      top: 0;
      width: 420px;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 60px;
      z-index: 10;
      background: linear-gradient(90deg,
        rgba(5,5,8,1) 0%,
        rgba(5,5,8,0.98) 60%,
        rgba(5,5,8,0.7) 85%,
        transparent 100%);
    }

    .status-code {
      font-size: 140px;
      font-weight: 100;
      color: #ff6600;
      line-height: 1;
      opacity: 0.08;
      position: absolute;
      top: 30px;
      left: 50px;
      letter-spacing: -12px;
      font-family: 'Helvetica Neue', sans-serif;
    }

    .title {
      font-size: 42px;
      font-weight: 200;
      color: #ffffff;
      margin-bottom: 12px;
      letter-spacing: -1px;
    }

    .subtitle {
      font-size: 15px;
      color: #00ffff;
      margin-bottom: 40px;
      opacity: 0.7;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .description {
      font-size: 14px;
      color: #666;
      line-height: 1.9;
      max-width: 340px;
    }

    .description a {
      color: #ff6600;
      text-decoration: none;
      transition: opacity 0.2s;
    }

    .description a:hover { opacity: 0.7; }

    .rule-display {
      margin-top: 50px;
      padding: 20px;
      background: rgba(255,102,0,0.03);
      border-left: 2px solid rgba(255,102,0,0.3);
    }

    .rule-label {
      font-size: 10px;
      color: #ff6600;
      opacity: 0.5;
      letter-spacing: 2px;
      margin-bottom: 8px;
    }

    .rule-text {
      font-size: 13px;
      color: #888;
      line-height: 1.6;
      font-style: italic;
    }

    #canvas {
      position: absolute;
      right: 0;
      top: 0;
      width: 100%;
      height: 100%;
    }

    .stats {
      position: absolute;
      bottom: 25px;
      right: 25px;
      font-size: 10px;
      color: #00ffff;
      opacity: 0.3;
      text-align: right;
      z-index: 10;
      letter-spacing: 1px;
    }

    .stats div { margin-bottom: 3px; }
    .stats span { color: #fff; opacity: 0.6; }

    .nav-hint {
      position: absolute;
      bottom: 25px;
      left: 60px;
      z-index: 10;
    }

    .nav-hint a {
      font-size: 11px;
      color: #ff6600;
      opacity: 0.4;
      text-decoration: none;
      letter-spacing: 1px;
      transition: opacity 0.2s;
    }

    .nav-hint a:hover { opacity: 0.8; }

    @media (max-width: 768px) {
      .message-panel {
        width: 100%;
        background: rgba(5,5,8,0.92);
        padding: 30px;
        justify-content: flex-start;
        padding-top: 100px;
      }
      .status-code { font-size: 80px; left: 30px; top: 20px; }
      .title { font-size: 28px; }
      .rule-display { display: none; }
    }
  </style>
</head>
<body>
  <div class="container">
    <canvas id="canvas"></canvas>

    <div class="status-code">404</div>

    <div class="message-panel">
      <h1 class="title">Coming Soon</h1>
      <p class="subtitle">Under Construction</p>
      <p class="description">
        This project is being built. The simulation shows
        how complexity emerges from simple rules — growth and decay in eternal balance.
      </p>

      <div class="rule-display">
        <div class="rule-label">THE RULES</div>
        <div class="rule-text">
          "Wander. Stick when you touch. Die when you're old."
        </div>
      </div>
    </div>

    <div class="nav-hint">
      <a href="https://too.foo">&larr; return to too.foo</a>
    </div>

    <div class="stats">
      <div>alive: <span id="alive">0</span></div>
      <div>born: <span id="born">0</span></div>
      <div>died: <span id="died">0</span></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    let grid; // 0 = empty, >0 = age of cell
    let particles = [];
    let aliveCount = 0;
    let bornTotal = 0;
    let diedTotal = 0;

    const PARTICLE_COUNT = 2000;
    const SCALE = 2;
    const MAX_AGE = 400;
    const DECAY_START = 200;

    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function getColor(age) {
      const t = age / MAX_AGE;

      // Young: bright orange (30°) → mature: cyan (180°) → old: dim blue (220°)
      let hue, sat, light;

      if (t < 0.15) {
        // Newborn: bright orange/yellow
        hue = 30 / 360;
        sat = 1.0;
        light = 0.6;
      } else if (t < 0.4) {
        // Growing: orange to cyan transition
        const p = (t - 0.15) / 0.25;
        hue = (30 + p * 150) / 360;
        sat = 0.9;
        light = 0.5;
      } else if (t < 0.7) {
        // Mature: cyan
        hue = 180 / 360;
        sat = 0.8;
        light = 0.45;
      } else {
        // Dying: fade to dark blue
        const p = (t - 0.7) / 0.3;
        hue = (180 + p * 40) / 360;
        sat = 0.6 - p * 0.4;
        light = 0.45 - p * 0.35;
      }

      const [r, g, b] = hslToRgb(hue, sat, light);
      return `rgb(${r},${g},${b})`;
    }

    function resize() {
      width = Math.floor(window.innerWidth / SCALE);
      height = Math.floor(window.innerHeight / SCALE);
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      ctx.imageSmoothingEnabled = false;
      init();
    }

    function init() {
      grid = new Uint16Array(width * height);
      particles = [];
      aliveCount = 0;
      bornTotal = 0;
      diedTotal = 0;

      // Multiple seed clusters
      const numSeeds = 8;
      for (let i = 0; i < numSeeds; i++) {
        const sx = Math.floor(width * 0.4 + Math.random() * width * 0.5);
        const sy = Math.floor(Math.random() * height);
        const idx = sy * width + sx;
        if (idx >= 0 && idx < grid.length) {
          grid[idx] = 1;
          aliveCount++;
          bornTotal++;
        }
      }

      for (let i = 0; i < PARTICLE_COUNT; i++) {
        spawnParticle();
      }
    }

    function spawnParticle() {
      let x, y;
      const r = Math.random();

      if (r < 0.4) {
        x = width - 1;
        y = Math.floor(Math.random() * height);
      } else if (r < 0.6) {
        x = Math.floor(width * 0.3 + Math.random() * width * 0.7);
        y = 0;
      } else if (r < 0.8) {
        x = Math.floor(width * 0.3 + Math.random() * width * 0.7);
        y = height - 1;
      } else {
        x = Math.floor(width * 0.4 + Math.random() * width * 0.55);
        y = Math.floor(Math.random() * height);
      }

      particles.push({ x, y, vx: 0, vy: 0 });
    }

    function getNeighborAge(x, y) {
      let maxAge = 0;
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
            const age = grid[ny * width + nx];
            if (age > 0 && age < MAX_AGE) {
              maxAge = Math.max(maxAge, age);
            }
          }
        }
      }
      return maxAge;
    }

    function update() {
      // Age all cells and kill old ones
      for (let i = 0; i < grid.length; i++) {
        if (grid[i] > 0) {
          grid[i]++;
          if (grid[i] >= MAX_AGE) {
            grid[i] = 0;
            aliveCount--;
            diedTotal++;
          }
        }
      }

      // Move particles
      const toRemove = [];

      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];

        // Brownian motion with momentum
        p.vx = p.vx * 0.5 + (Math.random() - 0.5) * 2;
        p.vy = p.vy * 0.5 + (Math.random() - 0.5) * 2;

        p.x += Math.round(p.vx);
        p.y += Math.round(p.vy);

        // Wrap or respawn at boundaries
        if (p.x < 0 || p.x >= width || p.y < 0 || p.y >= height) {
          toRemove.push(i);
          continue;
        }

        // Check for attachment
        const neighborAge = getNeighborAge(Math.floor(p.x), Math.floor(p.y));
        if (neighborAge > 0) {
          const stickiness = neighborAge < DECAY_START ? 0.4 : 0.1;
          if (Math.random() < stickiness) {
            const idx = Math.floor(p.y) * width + Math.floor(p.x);
            if (grid[idx] === 0) {
              grid[idx] = 1;
              aliveCount++;
              bornTotal++;
            }
            toRemove.push(i);
          }
        }
      }

      // Remove and respawn particles
      for (let i = toRemove.length - 1; i >= 0; i--) {
        particles.splice(toRemove[i], 1);
      }

      // Maintain particle count
      while (particles.length < PARTICLE_COUNT) {
        spawnParticle();
      }

      // Spontaneous new seeds if population is low
      if (aliveCount < 50 && Math.random() < 0.1) {
        const sx = Math.floor(width * 0.5 + Math.random() * width * 0.4);
        const sy = Math.floor(Math.random() * height);
        const idx = sy * width + sx;
        if (grid[idx] === 0) {
          grid[idx] = 1;
          aliveCount++;
          bornTotal++;
        }
      }
    }

    function draw() {
      // Fade background
      ctx.fillStyle = 'rgba(5, 5, 8, 0.3)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw cells
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const age = grid[y * width + x];
          if (age > 0) {
            ctx.fillStyle = getColor(age);
            ctx.fillRect(x * SCALE, y * SCALE, SCALE, SCALE);

            // Glow for young cells
            if (age < 30) {
              ctx.fillStyle = 'rgba(255, 150, 50, 0.15)';
              ctx.beginPath();
              ctx.arc(x * SCALE + SCALE/2, y * SCALE + SCALE/2, SCALE * 3, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }
      }

      // Draw particles (very subtle)
      ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
      for (const p of particles) {
        ctx.fillRect(Math.floor(p.x) * SCALE, Math.floor(p.y) * SCALE, SCALE, SCALE);
      }

      // Update stats
      document.getElementById('alive').textContent = aliveCount;
      document.getElementById('born').textContent = bornTotal;
      document.getElementById('died').textContent = diedTotal;
    }

    function animate() {
      for (let i = 0; i < 3; i++) {
        update();
      }
      draw();
      requestAnimationFrame(animate);
    }

    window.addEventListener('resize', resize);
    resize();
    animate();
  </script>
</body>
</html>
