<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Coming Soon | too.foo</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%;
      height: 100%;
      background: #050508;
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
      overflow: hidden;
      color: #e0e0e0;
    }

    .container {
      display: flex;
      width: 100%;
      height: 100%;
      position: relative;
    }

    .message-panel {
      position: absolute;
      left: 0;
      top: 0;
      width: 420px;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      padding: 60px;
      z-index: 10;
      background: linear-gradient(90deg,
        rgba(5,5,8,1) 0%,
        rgba(5,5,8,0.98) 60%,
        rgba(5,5,8,0.7) 85%,
        transparent 100%);
    }

    .status-code {
      font-size: 140px;
      font-weight: 100;
      color: #ff6600;
      line-height: 1;
      opacity: 0.08;
      position: absolute;
      top: 30px;
      left: 50px;
      letter-spacing: -12px;
      font-family: 'Helvetica Neue', sans-serif;
    }

    .title {
      font-size: 42px;
      font-weight: 200;
      color: #ffffff;
      margin-bottom: 12px;
      letter-spacing: -1px;
    }

    .subtitle {
      font-size: 15px;
      color: #0088ff;
      margin-bottom: 40px;
      opacity: 0.9;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .description {
      font-size: 14px;
      color: #666;
      line-height: 1.9;
      max-width: 340px;
    }

    .description a {
      color: #ff6600;
      text-decoration: none;
      transition: opacity 0.2s;
    }

    .description a:hover { opacity: 0.7; }

    .rule-display {
      margin-top: 50px;
      padding: 20px;
      background: rgba(255,102,0,0.03);
      border-left: 2px solid rgba(255,102,0,0.3);
    }

    .rule-label {
      font-size: 10px;
      color: #ff6600;
      opacity: 0.5;
      letter-spacing: 2px;
      margin-bottom: 8px;
    }

    .rule-text {
      font-size: 13px;
      color: #888;
      line-height: 1.6;
      font-style: italic;
    }

    #canvas {
      position: absolute;
      right: 0;
      top: 0;
      width: 100%;
      height: 100%;
    }

    .stats {
      position: absolute;
      bottom: 25px;
      right: 25px;
      font-size: 10px;
      color: #0088ff;
      opacity: 0.5;
      text-align: right;
      z-index: 10;
      letter-spacing: 1px;
    }

    .stats div { margin-bottom: 3px; }
    .stats span { color: #fff; opacity: 0.6; }

    .nav-hint {
      position: absolute;
      bottom: 25px;
      left: 60px;
      z-index: 10;
    }

    .nav-hint a {
      font-size: 11px;
      color: #ff6600;
      opacity: 0.4;
      text-decoration: none;
      letter-spacing: 1px;
      transition: opacity 0.2s;
    }

    .nav-hint a:hover { opacity: 0.8; }

    @media (max-width: 768px) {
      .message-panel {
        width: 100%;
        background: rgba(5,5,8,0.92);
        padding: 30px;
        justify-content: flex-start;
        padding-top: 100px;
      }
      .status-code { font-size: 80px; left: 30px; top: 20px; }
      .title { font-size: 28px; }
      .rule-display { display: none; }
    }
  </style>
</head>
<body>
  <div class="container">
    <canvas id="canvas"></canvas>

    <div class="status-code">404</div>

    <div class="message-panel">
      <h1 class="title">Coming Soon</h1>
      <p class="subtitle">Under Construction</p>
      <p class="description">
        This project is being built. The simulation shows
        how complexity emerges from simple rules â€” growth and decay in eternal balance.
      </p>

      <div class="rule-display">
        <div class="rule-label">THE RULES</div>
        <div class="rule-text">
          "Wander. Stick when you touch. Die when you're old."
        </div>
        <div class="rule-text" style="margin-top: 12px; color: #ff6600;">
          Helping others increases the odds for everyone to win.
        </div>
      </div>
    </div>

    <div class="nav-hint">
      <a href="https://too.foo">&larr; return to too.foo</a>
    </div>

    <div class="stats">
      <div>alive: <span id="alive">0</span></div>
      <div>born: <span id="born">0</span></div>
      <div>died: <span id="died">0</span></div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let width, height;
    let grid; // 0 = empty, >0 = age of cell
    let particles = [];
    let aliveCount = 0;
    let bornTotal = 0;
    let diedTotal = 0;

    const PARTICLE_COUNT = Math.floor((width * height) / 150);
    const SCALE = 2;
    const MAX_AGE = 500;
    const DECAY_START = 125;

    // Two colors only: bright orange and bright blue (high contrast)
    const ORANGE = '#ff6600';
    const BLUE = '#0088ff';

    function getColor(age) {
      const t = age / MAX_AGE;
      return t < 0.5 ? ORANGE : BLUE;
    }

    function resize() {
      width = Math.floor(window.innerWidth / SCALE);
      height = Math.floor(window.innerHeight / SCALE);
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      ctx.imageSmoothingEnabled = false;

      // Scale particle count to screen size for consistent density
      PARTICLE_COUNT = Math.floor((width * height) / 150);

      init();
    }

    function init() {
      grid = new Uint16Array(width * height);
      particles = [];
      aliveCount = 0;
      bornTotal = 0;
      diedTotal = 0;

      // Pre-seed with substantial clusters for immediate visual impact
      const numClusters = Math.floor(Math.sqrt(width * height) / 15);

      for (let c = 0; c < numClusters; c++) {
        const cx = Math.floor(width * 0.35 + Math.random() * width * 0.6);
        const cy = Math.floor(Math.random() * height);

        // Power law cluster sizes - mostly small, few large
        const clusterSize = Math.floor(Math.pow(Math.random(), 2) * 80) + 5;

        // Create organic cluster shape
        for (let i = 0; i < clusterSize; i++) {
          const angle = Math.random() * Math.PI * 2;
          const dist = Math.sqrt(Math.random()) * Math.sqrt(clusterSize) * 2;
          const x = Math.floor(cx + Math.cos(angle) * dist);
          const y = Math.floor(cy + Math.sin(angle) * dist);

          if (x >= 0 && x < width && y >= 0 && y < height) {
            const idx = y * width + x;
            if (grid[idx] === 0) {
              // Vary initial ages for visual interest
              grid[idx] = Math.floor(Math.random() * MAX_AGE * 0.3) + 1;
              aliveCount++;
              bornTotal++;
            }
          }
        }
      }

      // Spawn many particles immediately
      for (let i = 0; i < PARTICLE_COUNT; i++) {
        spawnParticle();
      }
    }

    function spawnParticle() {
      let x, y;
      const r = Math.random();

      if (r < 0.4) {
        x = width - 1;
        y = Math.floor(Math.random() * height);
      } else if (r < 0.6) {
        x = Math.floor(width * 0.3 + Math.random() * width * 0.7);
        y = 0;
      } else if (r < 0.8) {
        x = Math.floor(width * 0.3 + Math.random() * width * 0.7);
        y = height - 1;
      } else {
        x = Math.floor(width * 0.4 + Math.random() * width * 0.55);
        y = Math.floor(Math.random() * height);
      }

      particles.push({ x, y, vx: 0, vy: 0 });
    }

    function getNeighborAge(x, y) {
      let maxAge = 0;
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (dx === 0 && dy === 0) continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
            const age = grid[ny * width + nx];
            if (age > 0 && age < MAX_AGE) {
              maxAge = Math.max(maxAge, age);
            }
          }
        }
      }
      return maxAge;
    }

    function update() {
      // Age all cells and kill old ones
      for (let i = 0; i < grid.length; i++) {
        if (grid[i] > 0) {
          grid[i]++;
          if (grid[i] >= MAX_AGE) {
            grid[i] = 0;
            aliveCount--;
            diedTotal++;
          }
        }
      }

      // Move particles
      const toRemove = [];

      for (let i = 0; i < particles.length; i++) {
        const p = particles[i];

        // Fast Brownian motion
        p.vx = p.vx * 0.3 + (Math.random() - 0.5) * 4;
        p.vy = p.vy * 0.3 + (Math.random() - 0.5) * 4;

        p.x += Math.round(p.vx);
        p.y += Math.round(p.vy);

        // Wrap or respawn at boundaries
        if (p.x < 0 || p.x >= width || p.y < 0 || p.y >= height) {
          toRemove.push(i);
          continue;
        }

        // Check for attachment - high stickiness for fast growth
        const neighborAge = getNeighborAge(Math.floor(p.x), Math.floor(p.y));
        if (neighborAge > 0) {
          const stickiness = neighborAge < DECAY_START ? 0.7 : 0.3;
          if (Math.random() < stickiness) {
            const idx = Math.floor(p.y) * width + Math.floor(p.x);
            if (grid[idx] === 0) {
              grid[idx] = 1 + Math.floor(Math.random() * 50);
              aliveCount++;
              bornTotal++;
            }
            toRemove.push(i);
          }
        }
      }

      // Remove and respawn particles
      for (let i = toRemove.length - 1; i >= 0; i--) {
        particles.splice(toRemove[i], 1);
      }

      // Maintain particle count
      while (particles.length < PARTICLE_COUNT) {
        spawnParticle();
      }

      // Spontaneous new seeds - keeps things eventful
      const threshold = Math.floor(width * height / 500);
      if (aliveCount < threshold) {
        // Spawn a cluster, not just one cell
        const clusterSize = Math.floor(Math.random() * 20) + 5;
        const cx = Math.floor(width * 0.4 + Math.random() * width * 0.5);
        const cy = Math.floor(Math.random() * height);

        for (let i = 0; i < clusterSize; i++) {
          const angle = Math.random() * Math.PI * 2;
          const dist = Math.random() * 8;
          const sx = Math.floor(cx + Math.cos(angle) * dist);
          const sy = Math.floor(cy + Math.sin(angle) * dist);

          if (sx >= 0 && sx < width && sy >= 0 && sy < height) {
            const idx = sy * width + sx;
            if (grid[idx] === 0) {
              grid[idx] = 1;
              aliveCount++;
              bornTotal++;
            }
          }
        }
      }
    }

    function draw() {
      // Fade background
      ctx.fillStyle = 'rgba(5, 5, 8, 0.3)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw cells
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const age = grid[y * width + x];
          if (age > 0) {
            ctx.fillStyle = getColor(age);
            ctx.fillRect(x * SCALE, y * SCALE, SCALE, SCALE);

            // Glow for young cells (orange glow)
            if (age < 50) {
              ctx.fillStyle = 'rgba(255, 102, 0, 0.2)';
              ctx.beginPath();
              ctx.arc(x * SCALE + SCALE/2, y * SCALE + SCALE/2, SCALE * 4, 0, Math.PI * 2);
              ctx.fill();
            }
          }
        }
      }

      // Draw particles (very subtle)
      ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
      for (const p of particles) {
        ctx.fillRect(Math.floor(p.x) * SCALE, Math.floor(p.y) * SCALE, SCALE, SCALE);
      }

      // Update stats
      document.getElementById('alive').textContent = aliveCount;
      document.getElementById('born').textContent = bornTotal;
      document.getElementById('died').textContent = diedTotal;
    }

    function animate() {
      // Reduced updates per frame for smoother, more stable simulation
      for (let i = 0; i < 2; i++) {
        update();
      }
      draw();
      requestAnimationFrame(animate);
    }

    window.addEventListener('resize', resize);
    resize();
    animate();
  </script>
</body>
</html>
